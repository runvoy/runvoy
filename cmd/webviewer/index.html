<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
        runvoy Web Log Viewer
        See https://github.com/runvoy/runvoy for repo.
        Provided as part of the runvoy open source project.
        If you encounter a bug or would like to suggest an improvement,
        please file an issue at: https://github.com/runvoy/runvoy/issues
    -->
    <meta name="robots" content="noindex, nofollow">
    <meta name="description" content="View and interact with runvoy remote execution logs securely in your browser." />
    <meta name="author" content="runvoy contributors" />
    <title>runvoy Logs - {execution_id}</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <style>
        /* Custom styles for log container and ANSI colors */
        .log-container {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.875rem;
            line-height: 1.5;
            padding: 1rem;
            height: calc(100vh - 280px);
            min-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            background: var(--pico-background-color);
            border: 1px solid var(--pico-border-color);
            border-radius: var(--pico-border-radius);
        }

        .log-line {
            display: flex;
            white-space: pre-wrap;
            word-wrap: break-word;
            gap: 1rem;
        }

        .log-line:hover {
            background-color: rgba(128, 128, 128, 0.1);
        }

        .log-meta {
            flex-shrink: 0;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.75rem;
            color: #888;
            user-select: text;
            white-space: nowrap;
            text-align: right;
            min-width: 80px;
        }

        .log-line-number {
            color: #77abe7;
            font-weight: 600;
        }

        .log-content {
            flex: 1;
            min-width: 0;
        }

        .status {
            padding: 0.375rem 0.75rem;
            border-radius: var(--pico-border-radius);
            font-weight: bold;
            font-size: 0.875rem;
            white-space: nowrap;
        }

        .status.RUNNING {
            background: #ffa500;
            color: #000;
        }

        .status.SUCCEEDED {
            background: #4caf50;
            color: #000;
        }

        .status.FAILED {
            background: #f44336;
            color: #fff;
        }

        .status.STOPPED {
            background: #9e9e9e;
            color: #000;
        }

        /* ANSI color classes */
        .ansi-black { color: #000; }
        .ansi-red { color: #cd3131; }
        .ansi-green { color: #0dbc79; }
        .ansi-yellow { color: #e5e510; }
        .ansi-blue { color: #2472c8; }
        .ansi-magenta { color: #bc3fbc; }
        .ansi-cyan { color: #11a8cd; }
        .ansi-white { color: #e5e5e5; }
        .ansi-bright-black { color: #666; }
        .ansi-bright-red { color: #f14c4c; }

        /* Responsive header */
        .execution-header {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .execution-title-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.75rem;
        }

        @media (min-width: 768px) {
            .execution-header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
        }

        /* Responsive controls */
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }

        @media (min-width: 576px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (min-width: 768px) {
            .controls-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .controls-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        @media (min-width: 768px) {
            .controls-actions {
                grid-column: span 4;
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <header class="execution-header">
            <div>
                <h1>Runvoy logs viewer</h1>
                <div class="execution-title-row">
                    <h2>Execution: <input
                        type="text"
                        id="exec-id-input"
                        placeholder="Enter execution ID"
                        style="font-size: 1.5rem; font-weight: bold; border: 1px solid var(--pico-border-color); padding: 0.25rem 0.5rem; border-radius: var(--pico-border-radius); min-width: 200px;"
                    ></h2>
                    <span class="status" id="status">-</span>
                </div>
                <small>Started: <span id="started-at">-</span></small>
            </div>
        </header>

        <section>
            <div class="controls-grid">
                <input
                    type="text"
                    id="endpoint-input"
                    placeholder="Enter endpoint URL"
                >
                <input
                    type="password"
                    id="api-key-input"
                    placeholder="Enter API key (p_75LzCL...)"
                >
                <div class="controls-actions">
                    <button onclick="saveCredentials()">Save</button>
                    <button id="play-pause-btn" onclick="toggleConnection()">Connect</button>
                    <button onclick="downloadLogs()">Download</button>
                    <button onclick="clearLogs()">Clear</button>
                    <button id="metadata-toggle-btn" onclick="toggleMetadata()">Hide Metadata</button>
                </div>
            </div>
        </section>

        <section>
            <div id="log-container" class="log-container"></div>
        </section>
    </main>

    <script>
        // Configuration
        let API_ENDPOINT = null; // Loaded from localStorage

        // State
        let executionId = null;
        let apiKey = null;
        let logEvents = []; // Store all log events, sorted by timestamp
        let websocket = null;
        let isCompleted = false;
        let isConnecting = false;
        let showMetadata = true; // Whether to show line numbers and timestamps

        // Initialize
        document.addEventListener('DOMContentLoaded', init);

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            const urlParams = new URLSearchParams(window.location.search);
            const newExecutionId = urlParams.get('execution_id') || urlParams.get('executionId');
            const execIdInput = document.getElementById('exec-id-input');

            if (newExecutionId && newExecutionId !== executionId) {
                execIdInput.value = newExecutionId;
                switchExecutionId(newExecutionId);
            } else if (!newExecutionId && executionId) {
                execIdInput.value = '';
                executionId = null;
                closeWebSocket();
                document.getElementById('log-container').innerHTML = '';
                logEvents = [];
                isCompleted = false;
                updateStatus(null);
                updatePlayPauseButton();
            }
        });

        function init() {
            // Extract execution ID from URL query parameter
            const urlParams = new URLSearchParams(window.location.search);
            executionId = urlParams.get('execution_id') || urlParams.get('executionId');

            // Load credentials from localStorage
            API_ENDPOINT = localStorage.getItem('runvoy_endpoint');
            apiKey = localStorage.getItem('runvoy_api_key');

            if (API_ENDPOINT) {
                document.getElementById('endpoint-input').value = API_ENDPOINT;
            }
            if (apiKey) {
                document.getElementById('api-key-input').value = '••••••••';
            }

            // Update UI with execution ID
            const execIdInput = document.getElementById('exec-id-input');
            if (executionId) {
                execIdInput.value = executionId;
            } else {
                execIdInput.placeholder = 'Enter execution ID';
                appendLog('[INFO] Enter an execution ID above or provide ?execution_id=<id> in the URL\n');
            }

            // Add event listeners for execution ID changes
            execIdInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    switchExecutionId(execIdInput.value.trim());
                }
            });
            execIdInput.addEventListener('blur', function() {
                const newId = execIdInput.value.trim();
                if (newId && newId !== executionId) {
                    switchExecutionId(newId);
                }
            });

            updatePlayPauseButton();

            // Start fetching logs and status if we have an execution ID and credentials
            if (executionId && API_ENDPOINT && apiKey) {
                fetchStatus();
                fetchLogs();
                connectWebSocket();
            } else if (executionId) {
                appendLog('[INFO] Please enter endpoint URL and API key to view logs\n');
            }
        }

        function switchExecutionId(newExecutionId) {
            if (!newExecutionId || newExecutionId === executionId) {
                return;
            }

            // Update execution ID
            executionId = newExecutionId;

            // Update URL query parameter
            const urlParams = new URLSearchParams(window.location.search);
            urlParams.set('execution_id', executionId);
            const newUrl = window.location.pathname + '?' + urlParams.toString();
            window.history.pushState({ executionId: executionId }, '', newUrl);

            // Reset state
            document.getElementById('log-container').innerHTML = '';
            logEvents = [];
            isCompleted = false;
            isPaused = false;
            document.getElementById('started-at').textContent = '-';
            updateStatus(null);

            // Update play/pause button
            updatePlayPauseButton();

            // Close existing WebSocket
            closeWebSocket();

            // Start fetching new execution's logs and status
            if (API_ENDPOINT && apiKey) {
                appendLog(`[INFO] Switched to execution ID: ${executionId}\n`);
                fetchStatus();
                fetchLogs();
                connectWebSocket();
            } else {
                appendLog(`[INFO] Switched to execution ID: ${executionId}. Please enter endpoint URL and API key to view logs\n`);
            }
        }

        function saveCredentials() {
            const endpointInput = document.getElementById('endpoint-input');
            const keyInput = document.getElementById('api-key-input');
            const endpoint = endpointInput.value.trim();
            const key = keyInput.value;

            if (!endpoint) {
                alert('Please enter an endpoint URL');
                return;
            }

            if (!key || key === '••••••••') {
                alert('Please enter a valid API key');
                return;
            }

            // Validate URL format
            try {
                new URL(endpoint);
            } catch (e) {
                alert('Please enter a valid URL');
                return;
            }

            API_ENDPOINT = endpoint;
            apiKey = key;
            localStorage.setItem('runvoy_endpoint', endpoint);
            localStorage.setItem('runvoy_api_key', key);
            endpointInput.value = endpoint;
            keyInput.value = '••••••••';

            // Start fetching
            fetchStatus();
            fetchLogs();
            connectWebSocket();
        }

        async function fetchStatus() {
            if (!apiKey || !API_ENDPOINT) return;

            try {
                const url = `${API_ENDPOINT}/api/v1/executions/${executionId}/status`;
                const response = await fetch(url, {
                    headers: {
                        'X-API-Key': apiKey
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.details || 'Invalid API key');
                    }
                    if (response.status === 404) {
                        // Execution not found yet, keep trying
                        return;
                    }
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.details || `HTTP ${response.status}`);
                }

                const data = await response.json();

                // Update metadata
                if (data.started_at) {
                    // started_at is an ISO timestamp string from the API
                    document.getElementById('started-at').textContent = new Date(data.started_at).toLocaleString();
                }

                // Update status
                updateStatus(data.status);

                // Check if completed
                const terminalStatuses = ['SUCCEEDED', 'FAILED', 'STOPPED'];
                if (terminalStatuses.includes(data.status)) {
                    isCompleted = true;
                    closeWebSocket();
                    updatePlayPauseButton();
                    if (data.exit_code !== null && data.exit_code !== undefined) {
                        appendLog(`\n[INFO] Execution ${data.status} with exit code ${data.exit_code}\n`);
                    } else {
                        appendLog(`\n[INFO] Execution ${data.status}\n`);
                    }
                }
            } catch (error) {
                console.error('Failed to fetch status:', error);

                if (error.message.includes('Invalid API key') || error.message.includes('Unauthorized')) {
                    closeWebSocket();
                    localStorage.removeItem('runvoy_api_key');
                    document.getElementById('api-key-input').value = '';
                    appendLog(`\n[ERROR] Invalid API key. Please enter a valid key.\n`);
                }
            }
        }

        async function connectWebSocket() {
            if (!apiKey || !API_ENDPOINT || !executionId || isConnecting) return;

            // Close existing connection
            closeWebSocket();

            isConnecting = true;

            try {
                // Fetch WebSocket URL from the API
                const url = `${API_ENDPOINT}/api/v1/executions/${executionId}/logs/stream`;
                const response = await fetch(url, {
                    headers: {
                        'X-API-Key': apiKey
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.details || 'Invalid API key');
                    }
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.details || `HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('WebSocket stream response:', data);
                const wsURL = data.websocket_url;

                if (!wsURL || wsURL === '') {
                    appendLog(`[WARN] WebSocket URL not configured on server. Real-time streaming unavailable.\n`);
                    appendLog(`[INFO] You can still view logs via the static endpoint.\n`);
                    isConnecting = false;
                    updatePlayPauseButton();
                    return;
                }

                // Validate WebSocket URL format
                if (!wsURL.startsWith('wss://') && !wsURL.startsWith('ws://')) {
                    throw new Error(`Invalid WebSocket URL format: ${wsURL}. Must start with wss:// or ws://`);
                }

                appendLog(`[INFO] Connecting to WebSocket: ${wsURL}\n`);

                // Establish WebSocket connection
                websocket = new WebSocket(wsURL);

                websocket.onopen = () => {
                    appendLog(`[INFO] WebSocket connected. Listening for logs...\n`);
                    isConnecting = false;
                    updatePlayPauseButton();
                };

                websocket.onmessage = (event) => {
                    try {
                        const logEvent = JSON.parse(event.data);

                        // Check if we already have this log (by timestamp)
                        const existingIndex = logEvents.findIndex(e => e.timestamp === logEvent.timestamp);

                        if (existingIndex === -1) {
                            // New log event
                            logEvents.push(logEvent);
                            logEvents.sort((a, b) => a.timestamp - b.timestamp);
                            renderLogs();
                        }
                    } catch (err) {
                        console.error('Failed to parse WebSocket message:', err);
                    }
                };

                websocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    appendLog(`\n[ERROR] WebSocket connection error\n`);
                    isConnecting = false;
                    updatePlayPauseButton();
                };

                websocket.onclose = (event) => {
                    appendLog(`\n[INFO] WebSocket disconnected (code: ${event.code})\n`);
                    isConnecting = false;
                    websocket = null;
                    updatePlayPauseButton();

                    // Attempt reconnection if not completed and not a clean close
                    if (!isCompleted && event.code !== 1000) {
                        appendLog(`[INFO] Attempting to reconnect in 5 seconds...\n`);
                        setTimeout(() => {
                            if (!isCompleted && executionId) {
                                connectWebSocket();
                            }
                        }, 5000);
                    }
                };

            } catch (error) {
                console.error('Failed to connect to WebSocket:', error);
                appendLog(`\n[ERROR] Failed to connect: ${error.message}\n`);
                isConnecting = false;
                updatePlayPauseButton();

                if (error.message.includes('Invalid API key') || error.message.includes('Unauthorized')) {
                    localStorage.removeItem('runvoy_api_key');
                    document.getElementById('api-key-input').value = '';
                }
            }
        }

        function closeWebSocket() {
            if (websocket) {
                websocket.close(1000, 'Client closing connection');
                websocket = null;
            }
        }

        async function fetchLogs() {
            if (!apiKey || !API_ENDPOINT) return;

            try {
                const url = `${API_ENDPOINT}/api/v1/executions/${executionId}/logs`;
                const response = await fetch(url, {
                    headers: {
                        'X-API-Key': apiKey
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.details || 'Invalid API key');
                    }
                    if (response.status === 404) {
                        // Log stream doesn't exist yet, this is normal for new executions
                        return;
                    }
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.details || `HTTP ${response.status}`);
                }

                const data = await response.json();

                // Merge new events with existing events
                if (data.events && Array.isArray(data.events)) {
                    // Create a set of existing timestamps for quick lookup
                    const existingTimestamps = new Set(logEvents.map(e => e.timestamp));

                    // Filter out events we already have
                    const newEvents = data.events.filter(event => !existingTimestamps.has(event.timestamp));

                    if (newEvents.length > 0) {
                        // Add new events to our collection
                        logEvents.push(...newEvents);

                        // Sort all events by timestamp
                        logEvents.sort((a, b) => a.timestamp - b.timestamp);

                        // Re-render all logs with computed line numbers
                        renderLogs();
                    }
                }
            } catch (error) {
                console.error('Failed to fetch logs:', error);

                // Only show error if it's not a 404 (which means logs don't exist yet)
                if (!error.message.includes('404')) {
                    appendLog(`\n[ERROR] Failed to fetch logs: ${error.message}\n`);
                }

                if (error.message.includes('Invalid API key') || error.message.includes('Unauthorized')) {
                    closeWebSocket();
                    localStorage.removeItem('runvoy_api_key');
                    document.getElementById('api-key-input').value = '';
                }
            }
        }

        function renderLogs() {
            const container = document.getElementById('log-container');
            const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;

            // Clear container
            container.innerHTML = '';

            // Render all logs with computed line numbers
            logEvents.forEach((event, index) => {
                const lineNumber = index + 1; // 1-indexed line numbers
                appendLogToDOM(event.message, lineNumber, event.timestamp);
            });

            // Auto-scroll to bottom if we were already at bottom
            if (wasAtBottom) {
                container.scrollTop = container.scrollHeight;
            }
        }

        function appendLogToDOM(text, lineNumber, timestamp) {
            const container = document.getElementById('log-container');
            const parsed = parseAnsi(text);

            // Format metadata
            let metaHtml = '';
            if (showMetadata && lineNumber !== undefined) {
                // Format timestamp from milliseconds to readable date
                let timeStr = '';
                if (timestamp !== undefined && timestamp > 0) {
                    const date = new Date(timestamp);
                    // Format as YYYY-MM-DD HH:MM:SS
                    timeStr = date.toISOString().replace('T', ' ').substring(0, 19) + 'Z';
                }
                metaHtml = `<span class="log-meta"><span class="log-line-number">${lineNumber}</span>${timeStr ? ' ' + timeStr : ''}</span>`;
            }

            container.innerHTML += `<div class="log-line">${metaHtml}<span class="log-content">${parsed}</span></div>`;
        }

        function appendLog(text) {
            // For system messages (INFO, ERROR) that don't have timestamps
            const container = document.getElementById('log-container');
            const parsed = parseAnsi(text);
            container.innerHTML += `<div class="log-line"><span class="log-content">${parsed}</span></div>`;
            container.scrollTop = container.scrollHeight;
        }

        function parseAnsi(text) {
            // Simple ANSI parser (or use library like ansi-to-html)
            const ansiRegex = /\x1b\[(\d+)m/g;
            let result = text.replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;');

            // Color mappings
            const colorMap = {
                '30': 'black', '31': 'red', '32': 'green', '33': 'yellow',
                '34': 'blue', '35': 'magenta', '36': 'cyan', '37': 'white',
                '90': 'bright-black', '91': 'bright-red', // ... etc
            };

            result = result.replace(ansiRegex, (match, code) => {
                if (code === '0') return '</span>'; // Reset
                const color = colorMap[code];
                return color ? `<span class="ansi-${color}">` : '';
            });

            return result;
        }

        function updateStatus(status) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = status || '-';
            // Normalize status for CSS class (backend returns uppercase like RUNNING, SUCCEEDED, etc.)
            const statusClass = status ? status.toUpperCase() : '';
            statusEl.className = `status ${statusClass}`;
        }

        function toggleConnection() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                // Close WebSocket connection
                closeWebSocket();
                appendLog('[INFO] Disconnected from WebSocket\n');
            } else {
                // Reconnect WebSocket
                connectWebSocket();
            }
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            const btn = document.getElementById('play-pause-btn');
            if (btn) {
                if (isCompleted) {
                    btn.textContent = 'Completed';
                    btn.disabled = true;
                } else if (isConnecting) {
                    btn.textContent = 'Connecting...';
                    btn.disabled = true;
                } else if (websocket && websocket.readyState === WebSocket.OPEN) {
                    btn.textContent = 'Disconnect';
                    btn.disabled = false;
                } else {
                    btn.textContent = 'Connect';
                    btn.disabled = false;
                }
            }
        }

        function toggleMetadata() {
            showMetadata = !showMetadata;
            const btn = document.getElementById('metadata-toggle-btn');
            if (btn) {
                btn.textContent = showMetadata ? 'Hide Metadata' : 'Show Metadata';
            }
            // Re-render all logs with new metadata setting
            renderLogs();
        }

        function downloadLogs() {
            const container = document.getElementById('log-container');
            const text = container.innerText;
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `runvoy-${executionId}.log`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearLogs() {
            if (confirm('Clear log display? (logs are still stored in CloudWatch)')) {
                document.getElementById('log-container').innerHTML = '';
                logEvents = [];
            }
        }
    </script>
</body>
</html>