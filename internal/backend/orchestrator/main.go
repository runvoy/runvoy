package orchestrator

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"runvoy/internal/api"
	"runvoy/internal/auth/authorization"
	"runvoy/internal/backend/health"
	"runvoy/internal/backend/websocket"
	"runvoy/internal/constants"
	"runvoy/internal/database"
)

// Runner abstracts provider-specific command execution (e.g., AWS ECS, GCP, etc.).
type Runner interface {
	// StartTask triggers an execution on the underlying platform and returns
	// a stable executionID and the task creation timestamp.
	// The createdAt timestamp comes from the provider (e.g., ECS CreatedAt) when available.
	StartTask(
		ctx context.Context,
		userEmail string,
		req *api.ExecutionRequest) (executionID string, createdAt *time.Time, err error)
	// KillTask terminates a running task identified by executionID.
	// Returns an error if the task is already terminated or cannot be terminated.
	KillTask(ctx context.Context, executionID string) error
	// RegisterImage registers a Docker image as a task definition in the execution platform.
	// isDefault: if true, explicitly set as default.
	// taskRoleName: optional custom task role name (if nil, uses default from config).
	// taskExecutionRoleName: optional custom task execution role name (if nil, uses default from config).
	// cpu: optional CPU value (e.g., 256, 1024). Defaults to 256 if nil.
	// memory: optional Memory value in MB (e.g., 512, 2048). Defaults to 512 if nil.
	// runtimePlatform: optional runtime platform (e.g., "Linux/ARM64", "Linux/X86_64"). Defaults to "Linux/ARM64" if nil.
	// createdBy: email of the user registering the image.
	RegisterImage(
		ctx context.Context,
		image string,
		isDefault *bool,
		taskRoleName, taskExecutionRoleName *string,
		cpu, memory *int,
		runtimePlatform *string,
		createdBy string,
	) error
	// ListImages lists all registered Docker images.
	ListImages(ctx context.Context) ([]api.ImageInfo, error)

	// GetImage retrieves a single Docker image by ID or name.
	// Accepts either an ImageID (e.g., "alpine:latest-a1b2c3d4") or an image name (e.g., "alpine:latest").
	GetImage(ctx context.Context, image string) (*api.ImageInfo, error)

	// RemoveImage removes a Docker image and deregisters its task definitions.
	RemoveImage(ctx context.Context, image string) error

	// FetchLogsByExecutionID retrieves execution logs for a specific execution.
	// Returns logs generated by the user's command execution in containers (ECS tasks).
	// Distinct from backend logs which come from Lambda/API Gateway/infrastructure.
	// Returns empty slice if logs are not available or not supported by the provider.
	FetchLogsByExecutionID(ctx context.Context, executionID string) ([]api.LogEvent, error)

	// FetchBackendLogs retrieves backend infrastructure logs for the provided requestID.
	// Distinct from execution logs which come from user commands in containers.
	FetchBackendLogs(ctx context.Context, requestID string) (*api.BackendLogsResponse, error)
}

// Service provides the core business logic for command execution and user management.
type Service struct {
	userRepo      database.UserRepository
	executionRepo database.ExecutionRepository
	connRepo      database.ConnectionRepository
	tokenRepo     database.TokenRepository
	runner        Runner
	Logger        *slog.Logger
	Provider      constants.BackendProvider
	wsManager     websocket.Manager          // WebSocket manager for generating URLs and managing connections
	secretsRepo   database.SecretsRepository // Repository for managing secrets
	healthManager health.Manager             // Health manager for resource reconciliation
	enforcer      *authorization.Enforcer    // Enforcer for authorization
}

// NOTE: provider-specific configuration has been moved to sub packages (e.g., providers/aws/app).

// NewService creates a new service instance and initializes the enforcer with user roles from the database.
// Returns an error if the enforcer is configured but user roles cannot be loaded (critical initialization failure).
// Core repositories (userRepo, executionRepo) and enforcer are required for initialization and must be non-nil.
// If wsManager is nil, WebSocket URL generation will be skipped.
// If secretsRepo is nil, secrets operations will not be available.
// If healthManager is nil, health reconciliation will not be available.
func NewService(
	ctx context.Context,
	userRepo database.UserRepository,
	executionRepo database.ExecutionRepository,
	connRepo database.ConnectionRepository,
	tokenRepo database.TokenRepository,
	runner Runner,
	log *slog.Logger,
	provider constants.BackendProvider,
	wsManager websocket.Manager,
	secretsRepo database.SecretsRepository,
	healthManager health.Manager,
	enforcer *authorization.Enforcer) (*Service, error) {
	svc := &Service{
		userRepo:      userRepo,
		executionRepo: executionRepo,
		connRepo:      connRepo,
		tokenRepo:     tokenRepo,
		runner:        runner,
		Logger:        log,
		Provider:      provider,
		wsManager:     wsManager,
		secretsRepo:   secretsRepo,
		healthManager: healthManager,
		enforcer:      enforcer,
	}

	if err := enforcer.Hydrate(
		ctx,
		userRepo,
		executionRepo,
		secretsRepo,
		runner,
	); err != nil {
		return nil, fmt.Errorf("failed to hydrate enforcer: %w", err)
	}

	log.Debug("casbin authorization enforcer initialized successfully")
	log.Debug(fmt.Sprintf("%s %s orchestrator initialized successfully",
		constants.ProjectName, svc.Provider))
	return svc, nil
}

// GetEnforcer returns the Casbin enforcer for authorization checks.
func (s *Service) GetEnforcer() *authorization.Enforcer {
	return s.enforcer
}
