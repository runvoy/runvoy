// Package main provides a utility to generate a single markdown file documenting all CLI commands.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"runvoy/cmd/cli/cmd"
	"runvoy/internal/constants"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

func main() {
	var outFile string
	flag.StringVar(&outFile, "out", "./docs/CLI.md", "output file for generated markdown")
	flag.Parse()

	if outFile == "" {
		log.Fatal("error: output file is required")
	}

	if err := generateCLIDocs(outFile); err != nil {
		log.Fatalf("error: %s", err)
	}
}

func generateCLIDocs(outFile string) error {
	outDir := filepath.Dir(outFile)
	if err := os.MkdirAll(outDir, 0o750); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	file, err := os.Create(filepath.Clean(outFile))
	if err != nil {
		return fmt.Errorf("creating output file: %w", err)
	}
	defer func() {
		if closeErr := file.Close(); closeErr != nil {
			log.Printf("warning: error closing file: %v", closeErr)
		}
	}()

	root := cmd.RootCmd()
	root.DisableAutoGenTag = true

	// Write header
	if _, headerErr := fmt.Fprintln(file, "# Runvoy CLI Documentation"); headerErr != nil {
		return fmt.Errorf("writing header: %w", headerErr)
	}

	introText := "\nAutogenerated comprehensive guide to all Runvoy CLI commands."
	if _, introErr := fmt.Fprintln(file, introText); introErr != nil {
		return fmt.Errorf("writing introduction: %w", introErr)
	}

	// Generate documentation for all commands (starting at level 2 for root)
	docErr := generateDocs(root, file, 1, "")
	if docErr != nil {
		return fmt.Errorf("generating documentation: %w", docErr)
	}

	absPath, err := filepath.Abs(outFile)
	if err != nil {
		absPath = outFile
	}

	log.Printf("âœ… Successfully generated CLI documentation in %s", absPath)
	return nil
}

func generateDocs(cobraCmd *cobra.Command, file *os.File, _ int, _ string) error {
	if !cobraCmd.IsAvailableCommand() || cobraCmd.IsAdditionalHelpTopicCommand() {
		return nil
	}

	commandPath := cobraCmd.CommandPath()
	// All commands are at level 2 (##), options are at level 3 (###)
	commandLevel := 2
	headingPrefix := strings.Repeat("#", commandLevel)

	if err := writeDocHeader(file, headingPrefix, commandPath, cobraCmd); err != nil {
		return err
	}

	// Extract and write options from Cobra
	if err := writeOptionsSection(file, cobraCmd); err != nil {
		return err
	}

	if _, err := fmt.Fprintln(file); err != nil {
		return fmt.Errorf("writing newline: %w", err)
	}

	// Process subcommands recursively
	subcommands := cobraCmd.Commands()
	if len(subcommands) > 0 {
		sort.Slice(subcommands, func(i, j int) bool {
			return subcommands[i].Name() < subcommands[j].Name()
		})

		for _, subCmd := range subcommands {
			if err := generateDocs(subCmd, file, commandLevel, commandPath); err != nil {
				return err
			}
		}
	}

	return nil
}

func writeDocHeader(file *os.File, headingPrefix, commandPath string, cobraCmd *cobra.Command) error {
	// Write heading (anchor is auto-generated from heading text)
	if _, err := fmt.Fprintf(file, "%s %s\n\n", headingPrefix, commandPath); err != nil {
		return fmt.Errorf("writing heading: %w", err)
	}

	// Skip description for root command
	if commandPath == constants.ProjectName {
		return nil
	}

	if cobraCmd.Long != "" {
		if _, err := fmt.Fprintf(file, "%s\n\n", cobraCmd.Long); err != nil {
			return fmt.Errorf("writing long description: %w", err)
		}
	} else if cobraCmd.Short != "" {
		if _, err := fmt.Fprintf(file, "%s\n\n", cobraCmd.Short); err != nil {
			return fmt.Errorf("writing short description: %w", err)
		}
	}

	if cobraCmd.Example != "" {
		if _, err := fmt.Fprintf(file, "**Examples**\n\n```bash\n%s\n```\n\n", cobraCmd.Example); err != nil {
			return fmt.Errorf("writing examples: %w", err)
		}
	}

	return nil
}

func writeOptionsSection(file *os.File, cobraCmd *cobra.Command) error {
	// Generate markdown using Cobra's built-in function
	var buf bytes.Buffer
	if err := doc.GenMarkdown(cobraCmd, &buf); err != nil {
		return fmt.Errorf("generating markdown for options: %w", err)
	}

	markdown := buf.String()

	// Extract only the Options section (both local and inherited flags)
	if !strings.Contains(markdown, "### Options") {
		return nil
	}

	// Find the start of Options section
	start := strings.Index(markdown, "### Options")
	if start < 0 {
		return nil
	}

	optionsSection := markdown[start:]

	// Find the end of the Options section by looking for the next heading
	end := findSectionEnd(optionsSection)
	if end > 0 {
		optionsSection = optionsSection[:end]
	}

	// Count the number of options by counting lines that start with dashes
	// Split the options section into lines and count those starting with '-' or spaces followed by '-'
	lines := strings.Split(optionsSection, "\n")
	optionCount := 0
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "-") {
			optionCount++
		}
	}

	// Skip writing if only one option exists (which is always -h)
	if optionCount <= 1 {
		return nil
	}

	// Replace the Options heading with bold text
	optionsSection = strings.Replace(optionsSection, "### Options", "**Options**", 1)

	// Write the extracted Options section
	if _, err := fmt.Fprint(file, optionsSection); err != nil {
		return fmt.Errorf("writing options: %w", err)
	}

	return nil
}

func findSectionEnd(section string) int {
	// Look for the next heading (###, ##, or #)
	patterns := []string{"\\n### See Also", "\\n## ", "\\n### "}

	minIdx := -1
	for _, pattern := range patterns {
		// Simple pattern matching without regex
		searchStr := strings.TrimPrefix(pattern, "\\n")
		if idx := strings.Index(section[1:], "\n"+searchStr); idx >= 0 {
			idx++ // account for the search starting at position 1
			if minIdx < 0 || idx < minIdx {
				minIdx = idx
			}
		}
	}

	return minIdx
}
