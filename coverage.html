
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>event_processor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">runvoy/cmd/backend/aws/event_processor/main.go (0.0%)</option>
				
				<option value="file1">runvoy/cmd/backend/aws/orchestrator/main.go (0.0%)</option>
				
				<option value="file2">runvoy/cmd/local/main.go (0.0%)</option>
				
				<option value="file3">runvoy/cmd/runvoy/cmd/claim.go (52.2%)</option>
				
				<option value="file4">runvoy/cmd/runvoy/cmd/configure.go (76.9%)</option>
				
				<option value="file5">runvoy/cmd/runvoy/cmd/images.go (54.0%)</option>
				
				<option value="file6">runvoy/cmd/runvoy/cmd/kill.go (50.0%)</option>
				
				<option value="file7">runvoy/cmd/runvoy/cmd/list.go (75.7%)</option>
				
				<option value="file8">runvoy/cmd/runvoy/cmd/logs.go (56.0%)</option>
				
				<option value="file9">runvoy/cmd/runvoy/cmd/output_interface.go (0.0%)</option>
				
				<option value="file10">runvoy/cmd/runvoy/cmd/root.go (19.1%)</option>
				
				<option value="file11">runvoy/cmd/runvoy/cmd/run.go (72.2%)</option>
				
				<option value="file12">runvoy/cmd/runvoy/cmd/status.go (62.5%)</option>
				
				<option value="file13">runvoy/cmd/runvoy/cmd/users.go (64.9%)</option>
				
				<option value="file14">runvoy/cmd/runvoy/cmd/version.go (9.1%)</option>
				
				<option value="file15">runvoy/cmd/runvoy/main.go (0.0%)</option>
				
				<option value="file16">runvoy/internal/app/aws/logs.go (0.0%)</option>
				
				<option value="file17">runvoy/internal/app/aws/runner.go (0.0%)</option>
				
				<option value="file18">runvoy/internal/app/aws/taskdef.go (0.0%)</option>
				
				<option value="file19">runvoy/internal/app/init.go (0.0%)</option>
				
				<option value="file20">runvoy/internal/app/main.go (58.6%)</option>
				
				<option value="file21">runvoy/internal/auth/apikey.go (50.0%)</option>
				
				<option value="file22">runvoy/internal/client/client.go (0.9%)</option>
				
				<option value="file23">runvoy/internal/config/config.go (18.1%)</option>
				
				<option value="file24">runvoy/internal/constants/constants.go (100.0%)</option>
				
				<option value="file25">runvoy/internal/database/dynamodb/executions.go (26.6%)</option>
				
				<option value="file26">runvoy/internal/database/dynamodb/users.go (0.0%)</option>
				
				<option value="file27">runvoy/internal/errors/errors.go (100.0%)</option>
				
				<option value="file28">runvoy/internal/events/ecs_completion.go (81.4%)</option>
				
				<option value="file29">runvoy/internal/events/processor.go (47.4%)</option>
				
				<option value="file30">runvoy/internal/events/types.go (100.0%)</option>
				
				<option value="file31">runvoy/internal/lambdaapi/handler.go (0.0%)</option>
				
				<option value="file32">runvoy/internal/logger/context.go (100.0%)</option>
				
				<option value="file33">runvoy/internal/logger/logger.go (97.4%)</option>
				
				<option value="file34">runvoy/internal/output/output.go (64.5%)</option>
				
				<option value="file35">runvoy/internal/server/handlers.go (54.6%)</option>
				
				<option value="file36">runvoy/internal/server/middleware.go (90.2%)</option>
				
				<option value="file37">runvoy/internal/server/router.go (93.2%)</option>
				
				<option value="file38">runvoy/internal/testutil/assert.go (0.0%)</option>
				
				<option value="file39">runvoy/internal/testutil/fixtures.go (0.0%)</option>
				
				<option value="file40">runvoy/scripts/create-config-file/main.go (0.0%)</option>
				
				<option value="file41">runvoy/scripts/seed-admin-user/main.go (0.0%)</option>
				
				<option value="file42">runvoy/scripts/sync-env-vars/main.go (0.0%)</option>
				
				<option value="file43">runvoy/scripts/update-readme-help/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main implements the AWS Lambda event processor for runvoy.
// It processes CloudWatch events related to ECS task completions.
package main

import (
        "context"
        "os"

        "runvoy/internal/config"
        "runvoy/internal/constants"
        "runvoy/internal/events"
        "runvoy/internal/logger"

        "github.com/aws/aws-lambda-go/lambda"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoadEventProcessor()
        log := logger.Initialize(constants.Production, cfg.GetLogLevel())
        ctx, cancel := context.WithTimeout(context.Background(), cfg.InitTimeout)

        processor, err := events.NewProcessor(ctx, cfg, log)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to create event processor", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Debug("starting Lambda handler")
        lambda.Start(processor.HandleEvent)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package main implements the AWS Lambda orchestrator for runvoy.
// It handles API requests and orchestrates ECS task executions.
package main

import (
        "context"
        "os"

        "runvoy/internal/app"
        "runvoy/internal/config"
        "runvoy/internal/constants"
        "runvoy/internal/lambdaapi"
        "runvoy/internal/logger"

        "github.com/aws/aws-lambda-go/lambda"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoadOrchestrator()
        log := logger.Initialize(constants.Production, cfg.GetLogLevel())
        ctx, cancel := context.WithTimeout(context.Background(), cfg.InitTimeout)

        svc, err := app.Initialize(ctx, constants.AWS, cfg, log)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to initialize service", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Debug("starting Lambda handler")
        handler := lambdaapi.NewHandler(svc, cfg.RequestTimeout)
        lambda.Start(handler)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package main implements the local development server for runvoy.
// It runs the orchestrator service locally for testing and development.
package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"

        "runvoy/internal/app"
        "runvoy/internal/config"
        "runvoy/internal/constants"
        "runvoy/internal/logger"
        "runvoy/internal/server"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoadOrchestrator()
        log := logger.Initialize(constants.Development, cfg.GetLogLevel())
        ctx, cancel := context.WithTimeout(context.Background(), cfg.InitTimeout)

        svc, err := app.Initialize(ctx, constants.AWS, cfg, log)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to initialize service", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">router := server.NewRouter(svc, cfg.RequestTimeout)
        srv := &amp;http.Server{
                Addr:         fmt.Sprintf(":%s", cfg.Port),
                Handler:      router.Handler(),
                ReadTimeout:  constants.ServerReadTimeout,
                WriteTimeout: constants.ServerWriteTimeout,
                IdleTimeout:  constants.ServerIdleTimeout,
        }

        go func() </span><span class="cov0" title="0">{
                log.Info("starting local server",
                        "port", cfg.Port,
                        "version", *constants.GetVersion(),
                        "log_level", cfg.LogLevel,
                        "request_timeout", cfg.RequestTimeout,
                )
                log.Debug("health check available",
                        "url", fmt.Sprintf("http://localhost:%s/api/v1/health", cfg.Port),
                )

                if serveErr := srv.ListenAndServe(); serveErr != nil &amp;&amp; serveErr != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error("failed to start server", "error", serveErr)
                        os.Exit(1)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info("shutting down server...")

        ctx, cancel = context.WithTimeout(context.Background(), constants.ServerShutdownTimeout)

        if shutdownErr := srv.Shutdown(ctx); shutdownErr != nil </span><span class="cov0" title="0">{
                cancel()
                log.Error("server shutdown error", "error", shutdownErr)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">cancel()

        log.Info("server shutdown complete")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "runvoy/internal/client"
        "runvoy/internal/config"
        "runvoy/internal/constants"
        "runvoy/internal/output"

        "github.com/spf13/cobra"
)

var claimCmd = &amp;cobra.Command{
        Use:     "claim &lt;token&gt;",
        Short:   "Claim a user's API key",
        Long:    `Claim a user's API key using the given token`,
        Example: fmt.Sprintf(`  - %s claim 1234567890`, constants.ProjectName),
        Run:     runClaim,
        Args:    cobra.ExactArgs(1),
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(claimCmd)
}</span>

func runClaim(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        token := args[0]
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewClaimService(c, NewOutputWrapper(), NewConfigSaver())
        if err = service.ClaimAPIKey(cmd.Context(), token, cfg); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// ConfigSaver defines an interface for saving configuration
type ConfigSaver interface {
        Save(config *config.Config) error
}

// configSaverWrapper wraps the global config.Save function to implement ConfigSaver
type configSaverWrapper struct{}

func (c *configSaverWrapper) Save(cfg *config.Config) error <span class="cov0" title="0">{
        return config.Save(cfg)
}</span>

// NewConfigSaver creates a new ConfigSaver that uses the global config.Save function
func NewConfigSaver() ConfigSaver <span class="cov0" title="0">{
        return &amp;configSaverWrapper{}
}</span>

// ClaimService handles API key claiming logic
type ClaimService struct {
        client      client.Interface
        output      OutputInterface
        configSaver ConfigSaver
}

// NewClaimService creates a new ClaimService with the provided dependencies
func NewClaimService(apiClient client.Interface, outputter OutputInterface, configSaver ConfigSaver) *ClaimService <span class="cov8" title="1">{
        return &amp;ClaimService{
                client:      apiClient,
                output:      outputter,
                configSaver: configSaver,
        }
}</span>

// ClaimAPIKey claims an API key using the provided token and saves it to the config
func (s *ClaimService) ClaimAPIKey(ctx context.Context, token string, cfg *config.Config) error <span class="cov8" title="1">{
        resp, err := s.client.ClaimAPIKey(ctx, token)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to claim API key: %w", err)
        }</span>

        <span class="cov8" title="1">cfg.APIKey = resp.APIKey
        if err = s.configSaver.Save(cfg); err != nil </span><span class="cov8" title="1">{
                s.output.Errorf("failed to save API key to config: %v", err)
                s.output.Warningf("API Key =&gt; %s", s.output.Bold(resp.APIKey))
                return fmt.Errorf("failed to save API key to config: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("API key claimed successfully and saved to config")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package cmd implements the CLI commands for the runvoy tool.
package cmd

import (
        "context"
        "fmt"
        "runvoy/internal/config"
        "runvoy/internal/output"

        "github.com/spf13/cobra"
)

var configureCmd = &amp;cobra.Command{
        Use:   "configure",
        Short: "Configure local environment with API key and endpoint URL",
        Long: `Configure the local environment with your API key and endpoint URL.
This creates or updates the configuration file at ` + output.Bold("~/.runvoy/config.yaml"),
        Run: runConfigure,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(configureCmd)
}</span>

func runConfigure(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
        service := NewConfigureService(NewOutputWrapper(), NewConfigSaver(), config.Load, config.GetConfigPath)
        if err := service.Configure(context.Background()); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// ConfigLoader defines an interface for loading configuration
type ConfigLoader interface {
        Load() (*config.Config, error)
}

// configLoaderWrapper wraps the global config.Load function
type configLoaderWrapper struct{}

func (c *configLoaderWrapper) Load() (*config.Config, error) <span class="cov0" title="0">{
        return config.Load()
}</span>

// NewConfigLoader creates a new ConfigLoader that uses the global config.Load function
func NewConfigLoader() ConfigLoader <span class="cov0" title="0">{
        return &amp;configLoaderWrapper{}
}</span>

// ConfigPathGetter defines an interface for getting config path
type ConfigPathGetter interface {
        GetConfigPath() (string, error)
}

// configPathGetterWrapper wraps the global config.GetConfigPath function
type configPathGetterWrapper struct{}

func (c *configPathGetterWrapper) GetConfigPath() (string, error) <span class="cov0" title="0">{
        return config.GetConfigPath()
}</span>

// NewConfigPathGetter creates a new ConfigPathGetter that uses the global config.GetConfigPath function
func NewConfigPathGetter() ConfigPathGetter <span class="cov0" title="0">{
        return &amp;configPathGetterWrapper{}
}</span>

// ConfigureService handles configuration logic
type ConfigureService struct {
        output           OutputInterface
        configSaver      ConfigSaver
        configLoader     ConfigLoader
        configPathGetter ConfigPathGetter
}

// NewConfigureService creates a new ConfigureService with the provided dependencies
func NewConfigureService(
        outputter OutputInterface,
        configSaver ConfigSaver,
        configLoader func() (*config.Config, error),
        configPathGetter func() (string, error),
) *ConfigureService <span class="cov8" title="1">{
        return &amp;ConfigureService{
                output:           outputter,
                configSaver:      configSaver,
                configLoader:     &amp;configLoaderFunc{load: configLoader},
                configPathGetter: &amp;configPathGetterFunc{getPath: configPathGetter},
        }
}</span>

type configLoaderFunc struct {
        load func() (*config.Config, error)
}

func (c *configLoaderFunc) Load() (*config.Config, error) <span class="cov8" title="1">{
        return c.load()
}</span>

type configPathGetterFunc struct {
        getPath func() (string, error)
}

func (c *configPathGetterFunc) GetConfigPath() (string, error) <span class="cov8" title="1">{
        return c.getPath()
}</span>

// Configure runs the interactive configuration flow
func (s *ConfigureService) Configure(_ context.Context) error <span class="cov8" title="1">{
        existingConfig, err := s.configLoader.Load()
        configExists := err == nil

        if configExists </span><span class="cov8" title="1">{
                s.output.Successf("Found existing configuration")
        }</span> else<span class="cov8" title="1"> {
                existingConfig = &amp;config.Config{}
                s.output.Infof("Creating new configuration")
        }</span>

        <span class="cov8" title="1">endpoint := s.output.Prompt("Enter API endpoint URL")
        if endpoint == "" </span><span class="cov8" title="1">{
                if configExists &amp;&amp; existingConfig.APIEndpoint != "" </span><span class="cov8" title="1">{
                        endpoint = existingConfig.APIEndpoint
                        s.output.Infof("Using existing endpoint: %s", endpoint)
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("API endpoint is required")
                }</span>
        }

        <span class="cov8" title="1">apiKey := s.output.Prompt("Enter API key")
        if apiKey == "" </span><span class="cov8" title="1">{
                if configExists &amp;&amp; existingConfig.APIKey != "" </span><span class="cov8" title="1">{
                        apiKey = existingConfig.APIKey
                        s.output.Infof("Using existing API key")
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("API key is required")
                }</span>
        }

        <span class="cov8" title="1">cfg := &amp;config.Config{
                APIEndpoint: endpoint,
                APIKey:      apiKey,
        }

        if err = s.configSaver.Save(cfg); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        <span class="cov8" title="1">configPath, err := s.configPathGetter.GetConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get config path: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("Configuration saved successfully")
        s.output.KeyValue("Configuration path", configPath)
        s.output.Infof("Configuration complete!")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "runvoy/internal/api"
        "runvoy/internal/client"
        "runvoy/internal/constants"
        "runvoy/internal/output"
        "strconv"

        "github.com/spf13/cobra"
)

var imagesCmd = &amp;cobra.Command{
        Use:   "images",
        Short: "Images management commands",
}

var (
        registerImageIsDefault bool
)

var registerImageCmd = &amp;cobra.Command{
        Use:   "register &lt;image&gt;",
        Short: "Register a new image",
        Example: fmt.Sprintf(`  - %s images register alpine:latest
  - %s images register ecr-public.us-east-1.amazonaws.com/docker/library/ubuntu:22.04
  - %s images register ubuntu:22.04 --set-default`,
                constants.ProjectName,
                constants.ProjectName,
                constants.ProjectName,
        ),
        Run:  registerImageRun,
        Args: cobra.ExactArgs(1),
}

var listImagesCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List all images",
        Run:   listImagesRun,
}

var unregisterImageCmd = &amp;cobra.Command{
        Use:     "unregister &lt;image&gt;",
        Short:   "Unregister an image",
        Example: fmt.Sprintf(`  - %s images unregister alpine:latest`, constants.ProjectName),
        Run:     unregisterImageRun,
        Args:    cobra.ExactArgs(1),
}

func init() <span class="cov8" title="1">{
        registerImageCmd.Flags().BoolVar(&amp;registerImageIsDefault,
                "set-default", false, "Set this image as the default image")
        imagesCmd.AddCommand(registerImageCmd)
        imagesCmd.AddCommand(listImagesCmd)
        imagesCmd.AddCommand(unregisterImageCmd)
        rootCmd.AddCommand(imagesCmd)
}</span>

func registerImageRun(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        image := args[0]
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">var isDefault *bool
        if cmd.Flags().Changed("set-default") </span><span class="cov0" title="0">{
                isDefault = &amp;registerImageIsDefault
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewImagesService(c, NewOutputWrapper())
        if err = service.RegisterImage(cmd.Context(), image, isDefault); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

func listImagesRun(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewImagesService(c, NewOutputWrapper())
        if err = service.ListImages(cmd.Context()); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

func unregisterImageRun(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        image := args[0]
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewImagesService(c, NewOutputWrapper())
        if err = service.UnregisterImage(cmd.Context(), image); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// ImagesService handles image management logic
type ImagesService struct {
        client client.Interface
        output OutputInterface
}

// NewImagesService creates a new ImagesService with the provided dependencies
func NewImagesService(apiClient client.Interface, outputter OutputInterface) *ImagesService <span class="cov8" title="1">{
        return &amp;ImagesService{
                client: apiClient,
                output: outputter,
        }
}</span>

// RegisterImage registers a new image
func (s *ImagesService) RegisterImage(ctx context.Context, image string, isDefault *bool) error <span class="cov8" title="1">{
        resp, err := s.client.RegisterImage(ctx, image, isDefault)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to register image: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("Image registered successfully")
        s.output.KeyValue("Image", resp.Image)
        if resp.Message != "" </span><span class="cov8" title="1">{
                s.output.KeyValue("Message", resp.Message)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ListImages lists all registered images
func (s *ImagesService) ListImages(ctx context.Context) error <span class="cov8" title="1">{
        resp, err := s.client.ListImages(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to list images: %w", err)
        }</span>

        <span class="cov8" title="1">rows := s.formatImages(resp.Images)

        s.output.Blank()
        s.output.Table(
                []string{
                        "Image",
                        "Is Default",
                },
                rows,
        )
        s.output.Blank()
        s.output.Successf("Images listed successfully")
        return nil</span>
}

// UnregisterImage unregisters an image
func (s *ImagesService) UnregisterImage(ctx context.Context, image string) error <span class="cov8" title="1">{
        resp, err := s.client.UnregisterImage(ctx, image)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to remove image: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("Image removed successfully")
        s.output.KeyValue("Image", resp.Image)
        s.output.KeyValue("Message", resp.Message)
        return nil</span>
}

// formatImages formats image data into table rows
func (s *ImagesService) formatImages(images []api.ImageInfo) [][]string <span class="cov8" title="1">{
        rows := make([][]string, 0, len(images))
        for _, image := range images </span><span class="cov8" title="1">{
                rows = append(rows, []string{
                        image.Image,
                        strconv.FormatBool(*image.IsDefault),
                })
        }</span>
        <span class="cov8" title="1">return rows</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "runvoy/internal/client"
        "runvoy/internal/output"

        "github.com/spf13/cobra"
)

var killCmd = &amp;cobra.Command{
        Use:   "kill &lt;execution-id&gt;",
        Short: "Kill a running command execution",
        Long:  `Kill a running command execution`,
        Run:   killRun,
        Args:  cobra.ExactArgs(1),
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(killCmd)
}</span>

func killRun(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        executionID := args[0]
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewKillService(c, NewOutputWrapper())
        if err = service.KillExecution(cmd.Context(), executionID); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// KillService handles execution killing logic
type KillService struct {
        client client.Interface
        output OutputInterface
}

// NewKillService creates a new KillService with the provided dependencies
func NewKillService(apiClient client.Interface, outputter OutputInterface) *KillService <span class="cov8" title="1">{
        return &amp;KillService{
                client: apiClient,
                output: outputter,
        }
}</span>

// KillExecution kills a running execution and displays the results
func (s *KillService) KillExecution(ctx context.Context, executionID string) error <span class="cov8" title="1">{
        resp, err := s.client.KillExecution(ctx, executionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to kill execution: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("Execution killed successfully")
        s.output.KeyValue("Execution ID", resp.ExecutionID)
        s.output.KeyValue("Message", resp.Message)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "runvoy/internal/api"
        "runvoy/internal/client"
        "runvoy/internal/output"
        "time"

        "github.com/spf13/cobra"
)

const maxCommandLength = 40

var executionsCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List executions",
        Long:  "List all executions present in the runvoy backend",
        Run:   executionsRun,
        PostRun: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
                output.Blank()
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(executionsCmd)
}</span>

func executionsRun(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewListService(c, NewOutputWrapper())
        if err = service.ListExecutions(cmd.Context()); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// ListService handles execution listing and formatting logic
type ListService struct {
        client client.Interface
        output OutputInterface
}

// NewListService creates a new ListService with the provided dependencies
func NewListService(apiClient client.Interface, outputter OutputInterface) *ListService <span class="cov8" title="1">{
        return &amp;ListService{
                client: apiClient,
                output: outputter,
        }
}</span>

// ListExecutions lists all executions and displays them in a table format
func (s *ListService) ListExecutions(ctx context.Context) error <span class="cov8" title="1">{
        s.output.Infof("Listing executionsâ€¦")

        execs, err := s.client.ListExecutions(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to list executions: %w", err)
        }</span>

        <span class="cov8" title="1">rows := s.formatExecutions(execs)

        s.output.Blank()
        s.output.Table(
                []string{
                        "Execution ID",
                        "Status",
                        "Command",
                        "User",
                        "Started (UTC)",
                        "Completed (UTC)",
                        "Duration",
                },
                rows,
        )
        s.output.Blank()
        s.output.Successf("Executions listed successfully")
        return nil</span>
}

// formatExecutions formats execution data into table rows
func (s *ListService) formatExecutions(execs []api.Execution) [][]string <span class="cov8" title="1">{
        rows := make([][]string, 0, len(execs))
        for i := range execs </span><span class="cov8" title="1">{
                e := &amp;execs[i]
                started := e.StartedAt.UTC().Format(time.DateTime)
                completed := ""
                if e.CompletedAt != nil </span><span class="cov8" title="1">{
                        completed = e.CompletedAt.UTC().Format(time.DateTime)
                }</span>
                <span class="cov8" title="1">duration := ""
                if e.DurationSeconds &gt; 0 </span><span class="cov8" title="1">{
                        duration = fmt.Sprintf("%ds", e.DurationSeconds)
                }</span>

                <span class="cov8" title="1">command := ""
                if len(e.Command) &gt; maxCommandLength </span><span class="cov8" title="1">{
                        command = e.Command[:maxCommandLength] + "..."
                }</span> else<span class="cov8" title="1"> {
                        command = e.Command
                }</span>

                <span class="cov8" title="1">rows = append(rows, []string{
                        s.output.Bold(e.ExecutionID),
                        e.Status,
                        command,
                        e.UserEmail,
                        started,
                        completed,
                        duration,
                })</span>
        }
        <span class="cov8" title="1">return rows</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "runvoy/internal/client"
        "runvoy/internal/constants"
        "runvoy/internal/output"
        "time"

        "github.com/spf13/cobra"
)

var logsCmd = &amp;cobra.Command{
        Use:   "logs &lt;execution-id&gt;",
        Short: "Get logs for an execution",
        Long:  `Get logs for an execution`,
        Run:   logsRun,
        PostRun: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
                output.Blank()
        }</span>,
        Args: cobra.ExactArgs(1),
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(logsCmd)
}</span>

func logsRun(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        executionID := args[0]
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">output.Infof("Getting logs for execution: %s", output.Bold(executionID))

        c := client.New(cfg, slog.Default())
        service := NewLogsService(c, NewOutputWrapper())
        if err = service.DisplayLogs(cmd.Context(), executionID, cfg.GetWebviewerURL()); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// LogsService handles log display logic
type LogsService struct {
        client client.Interface
        output OutputInterface
}

// NewLogsService creates a new LogsService with the provided dependencies
func NewLogsService(apiClient client.Interface, outputter OutputInterface) *LogsService <span class="cov8" title="1">{
        return &amp;LogsService{
                client: apiClient,
                output: outputter,
        }
}</span>

// DisplayLogs retrieves and displays logs for an execution
func (s *LogsService) DisplayLogs(ctx context.Context, executionID, webviewerURL string) error <span class="cov8" title="1">{
        resp, err := s.client.GetLogs(ctx, executionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get logs: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Blank()
        rows := [][]string{}
        for _, log := range resp.Events </span><span class="cov8" title="1">{
                rows = append(rows, []string{
                        s.output.Bold(fmt.Sprintf("%d", log.Line)),
                        time.Unix(log.Timestamp/constants.MillisecondsPerSecond, 0).UTC().Format(time.DateTime),
                        log.Message,
                })
        }</span>
        <span class="cov8" title="1">s.output.Table([]string{"Line", "Timestamp (UTC)", "Message"}, rows)
        s.output.Blank()
        s.output.Successf("Logs retrieved successfully")
        s.output.Infof("View logs in web viewer: %s?execution_id=%s",
                webviewerURL, s.output.Cyan(executionID))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import "runvoy/internal/output"

// OutputInterface defines the interface for output operations to enable dependency injection and testing
type OutputInterface interface {
        Infof(format string, a ...interface{})
        Errorf(format string, a ...interface{})
        Successf(format string, a ...interface{})
        Warningf(format string, a ...interface{})
        Table(headers []string, rows [][]string)
        Blank()
        Bold(text string) string
        Cyan(text string) string
        KeyValue(key, value string)
        Prompt(prompt string) string
}

// outputWrapper wraps the global output package functions to implement OutputInterface
type outputWrapper struct{}

// NewOutputWrapper creates a new output wrapper that implements OutputInterface
func NewOutputWrapper() OutputInterface <span class="cov0" title="0">{
        return &amp;outputWrapper{}
}</span>

func (o *outputWrapper) Infof(format string, a ...interface{}) <span class="cov0" title="0">{
        output.Infof(format, a...)
}</span>

func (o *outputWrapper) Errorf(format string, a ...interface{}) <span class="cov0" title="0">{
        output.Errorf(format, a...)
}</span>

func (o *outputWrapper) Successf(format string, a ...interface{}) <span class="cov0" title="0">{
        output.Successf(format, a...)
}</span>

func (o *outputWrapper) Warningf(format string, a ...interface{}) <span class="cov0" title="0">{
        output.Warningf(format, a...)
}</span>

func (o *outputWrapper) Table(headers []string, rows [][]string) <span class="cov0" title="0">{
        output.Table(headers, rows)
}</span>

func (o *outputWrapper) Blank() <span class="cov0" title="0">{
        output.Blank()
}</span>

func (o *outputWrapper) Bold(text string) string <span class="cov0" title="0">{
        return output.Bold(text)
}</span>

func (o *outputWrapper) Cyan(text string) string <span class="cov0" title="0">{
        return output.Cyan(text)
}</span>

func (o *outputWrapper) KeyValue(key, value string) <span class="cov0" title="0">{
        output.KeyValue(key, value)
}</span>

func (o *outputWrapper) Prompt(prompt string) string <span class="cov0" title="0">{
        return output.Prompt(prompt)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "os"
        "strconv"
        "time"

        "runvoy/internal/config"
        "runvoy/internal/constants"
        "runvoy/internal/logger"
        "runvoy/internal/output"

        "github.com/spf13/cobra"
)

var (
        debug         bool
        timeout       string
        timeoutCancel context.CancelFunc
        verbose       bool
)

var rootCmd = &amp;cobra.Command{
        Use:   constants.ProjectName,
        Short: constants.ProjectName,
        Long: fmt.Sprintf(`%s - %s
Isolated, repeatable execution environments for your commands`,
                constants.ProjectName, *constants.GetVersion()),
        PersistentPreRunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                startTime := time.Now().UTC()
                cmd.SetContext(context.WithValue(cmd.Context(), constants.StartTimeCtxKey, startTime))
                printHeader(cmd)

                if verbose </span><span class="cov0" title="0">{
                        output.Infof("CLI build: " + output.Bold(*constants.GetVersion()))
                        output.Infof("Verbose output enabled")
                }</span>

                <span class="cov0" title="0">logLevel := slog.LevelInfo
                if debug </span><span class="cov0" title="0">{
                        logLevel = slog.LevelDebug
                }</span>
                <span class="cov0" title="0">logger := logger.Initialize(constants.CLI, logLevel)

                if timeout == "0" </span><span class="cov0" title="0">{
                        if verbose </span><span class="cov0" title="0">{
                                output.Infof("Timeout disabled")
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }

                // NOTICE: this runs after flags are parsed but before the command runs
                <span class="cov0" title="0">timeoutDuration, err := parseTimeout(timeout)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error parsing timeout: %w", err)
                }</span>

                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(cmd.Context(), timeoutDuration)
                timeoutCancel = cancel // Store for cleanup in Execute()
                cmd.SetContext(ctx)

                if verbose </span><span class="cov0" title="0">{
                        output.Infof("Timeout: %s", timeoutDuration)
                }</span>

                <span class="cov0" title="0">cfg, err := config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to load configuration", "error", err)
                        return nil
                }</span>

                <span class="cov0" title="0">configPath, err := config.GetConfigPath()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to get config path", "error", err)
                        return nil
                }</span>

                <span class="cov0" title="0">cmd.SetContext(context.WithValue(cmd.Context(), constants.ConfigCtxKey, cfg))
                if verbose </span><span class="cov0" title="0">{
                        output.Infof("Loaded configuration from %s", output.Bold(configPath))
                        output.Infof("API endpoint: %s", output.Bold(cfg.APIEndpoint))
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
        PersistentPostRun: func(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        startTime := getStartTimeFromContext(cmd)
                        if !startTime.IsZero() </span><span class="cov0" title="0">{
                                output.Infof("Time elapsed: %s", output.Bold(time.Since(startTime).String()))
                        }</span>
                }
                <span class="cov0" title="0">if timeoutCancel != nil </span><span class="cov0" title="0">{
                        timeoutCancel()
                }</span>
        },
}

// Execute runs the root command and handles cleanup of timeout context.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if timeoutCancel != nil </span><span class="cov0" title="0">{
                timeoutCancel()
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.PersistentFlags().StringVar(&amp;timeout, "timeout", "10m", "Timeout for command execution (e.g., 10m, 30s, 1h)")
        rootCmd.PersistentFlags().BoolVar(&amp;verbose, "verbose", false, "Verbose output")
        rootCmd.PersistentFlags().BoolVar(&amp;debug, "debug", false, "Enable debugging logs")
}</span>

// parseTimeout parses timeout string to time.Duration
// defaults to 10 minutes if empty
// Supports formats: "10m", "30s", "1h", "600s" (number of seconds)
func parseTimeout(timeoutStr string) (time.Duration, error) <span class="cov8" title="1">{
        if timeoutStr == "" </span><span class="cov8" title="1">{
                timeoutStr = "10m"
        }</span>

        // Try parsing as duration first (supports "10m", "30s", "1h", etc.)
        <span class="cov8" title="1">duration, err := time.ParseDuration(timeoutStr)
        if err == nil </span><span class="cov8" title="1">{
                return duration, nil
        }</span>

        // If duration parsing fails, try parsing as seconds (integer)
        <span class="cov8" title="1">seconds, err := strconv.Atoi(timeoutStr)
        if err != nil </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf(
                        "invalid timeout format: %s (use duration like '10m' or '30s', or seconds like '600')",
                        timeoutStr)
                return 0, errors.New(errMsg)
        }</span>

        <span class="cov8" title="1">return time.Duration(seconds) * time.Second, nil</span>
}

func printHeader(cmd *cobra.Command) <span class="cov0" title="0">{
        output.Header(output.Bold("ðŸš€ " + constants.ProjectName + " " + cmd.CalledAs()))
}</span>

// getConfigFromContext retrieves the config from the command context
func getConfigFromContext(cmd *cobra.Command) (*config.Config, error) <span class="cov0" title="0">{
        cfg, ok := cmd.Context().Value(constants.ConfigCtxKey).(*config.Config)
        if !ok || cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config not found in context")
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}

func getStartTimeFromContext(cmd *cobra.Command) time.Time <span class="cov0" title="0">{
        startTime, ok := cmd.Context().Value(constants.StartTimeCtxKey).(time.Time)
        if !ok </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">return startTime</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "runvoy/internal/api"
        "runvoy/internal/client"
        "runvoy/internal/constants"
        "runvoy/internal/output"
        "sort"
        "strings"

        "github.com/spf13/cobra"
)

var runCmd = &amp;cobra.Command{
        Use:   "run &lt;command&gt;",
        Short: "Run a command",
        Long: `Run a command in a remote environment with optional Git repository cloning.

User environment variables prefixed with RUNVOY_USER_ are saved to .env file
in the command working directory.`,
        Example: fmt.Sprintf(`  - %s run echo hello world
  - %s run terraform plan

  # With Git repository cloning
  - %s run --git-repo https://github.com/mycompany/myproject.git npm run test

  - %s run --git-repo https://github.com/ansible/ansible-examples.git \
               --git-ref main \
               --git-path ansible-examples/playbooks/hello_world \
               ansible-playbook site.yml

  # With user environment variables
  - RUNVOY_USER_MY_VAR=1234567890 %s run cat .env # Outputs =&gt; MY_VAR=1234567890
`, constants.ProjectName, constants.ProjectName, constants.ProjectName, constants.ProjectName, constants.ProjectName),
        Run:  runRun,
        Args: cobra.MinimumNArgs(1),
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(runCmd)
        runCmd.Flags().StringP("git-repo", "g", "", "Git repository URL")
        runCmd.Flags().StringP("git-ref", "r", "", "Git reference")
        runCmd.Flags().StringP("git-path", "p", "", "Git path")
        runCmd.Flags().StringP("image", "i", "", "Image to use")
}</span>

func runRun(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        command := strings.Join(args, " ")
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">envs := extractUserEnvVars(os.Environ())
        gitRepo := cmd.Flag("git-repo").Value.String()
        gitRef := cmd.Flag("git-ref").Value.String()
        gitPath := cmd.Flag("git-path").Value.String()
        image := cmd.Flag("image").Value.String()

        c := client.New(cfg, slog.Default())
        service := NewRunService(c, NewOutputWrapper())
        req := ExecuteCommandRequest{
                Command:      command,
                GitRepo:      gitRepo,
                GitRef:       gitRef,
                GitPath:      gitPath,
                Image:        image,
                Env:          envs,
                WebviewerURL: cfg.GetWebviewerURL(),
        }
        if err = service.ExecuteCommand(cmd.Context(), &amp;req); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

func extractUserEnvVars(envVars []string) map[string]string <span class="cov8" title="1">{
        envs := make(map[string]string)
        for _, env := range envVars </span><span class="cov8" title="1">{
                parts := strings.SplitN(env, "=", constants.EnvVarSplitLimit)
                if len(parts) != constants.EnvVarSplitLimit </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := parts[0]
                if strings.HasPrefix(key, "RUNVOY_USER_") </span><span class="cov8" title="1">{
                        envs[strings.TrimPrefix(key, "RUNVOY_USER_")] = parts[1]
                }</span>
        }

        <span class="cov8" title="1">return envs</span>
}

// ExecuteCommandRequest contains all parameters needed to execute a command
type ExecuteCommandRequest struct {
        Command      string
        GitRepo      string
        GitRef       string
        GitPath      string
        Image        string
        Env          map[string]string
        WebviewerURL string
}

// RunService handles command execution logic
type RunService struct {
        client client.Interface
        output OutputInterface
}

// NewRunService creates a new RunService with the provided dependencies
func NewRunService(apiClient client.Interface, outputter OutputInterface) *RunService <span class="cov8" title="1">{
        return &amp;RunService{
                client: apiClient,
                output: outputter,
        }
}</span>

// ExecuteCommand executes a command remotely and displays the results
func (s *RunService) ExecuteCommand(ctx context.Context, req *ExecuteCommandRequest) error <span class="cov8" title="1">{
        s.output.Infof("Running command: %s", s.output.Bold(req.Command))
        if req.GitRepo != "" </span><span class="cov8" title="1">{
                s.output.Infof("Git repository: %s", s.output.Bold(req.GitRepo))
        }</span>
        <span class="cov8" title="1">if req.GitRef != "" </span><span class="cov8" title="1">{
                s.output.Infof("Git reference: %s", s.output.Bold(req.GitRef))
        }</span>
        <span class="cov8" title="1">if req.GitPath != "" </span><span class="cov8" title="1">{
                s.output.Infof("Git path: %s", s.output.Bold(req.GitPath))
        }</span>

        <span class="cov8" title="1">var envKeys []string
        for key := range req.Env </span><span class="cov8" title="1">{
                envKeys = append(envKeys, key)
        }</span>
        <span class="cov8" title="1">if len(envKeys) &gt; 0 </span><span class="cov8" title="1">{
                sort.Strings(envKeys)
                s.output.Infof("Injecting user environment variables: %s", s.output.Bold(strings.Join(envKeys, ", ")))
        }</span>

        <span class="cov8" title="1">execReq := api.ExecutionRequest{
                Command: req.Command,
                GitRepo: req.GitRepo,
                GitRef:  req.GitRef,
                GitPath: req.GitPath,
                Env:     req.Env,
                Image:   req.Image,
        }
        resp, err := s.client.RunCommand(ctx, &amp;execReq)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to run command: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("Command execution started successfully")
        s.output.KeyValue("Execution ID", s.output.Cyan(resp.ExecutionID))
        s.output.KeyValue("Status", resp.Status)
        if req.Image != "" </span><span class="cov8" title="1">{
                s.output.KeyValue("Image", s.output.Cyan(req.Image))
        }</span>
        <span class="cov8" title="1">s.output.Infof("View logs in web viewer: %s?execution_id=%s",
                req.WebviewerURL, s.output.Cyan(resp.ExecutionID))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "runvoy/internal/client"
        "runvoy/internal/output"
        "time"

        "github.com/spf13/cobra"
)

var statusCmd = &amp;cobra.Command{
        Use:   "status &lt;execution-id&gt;",
        Short: "Get the status of a command execution",
        Run:   statusRun, Args: cobra.ExactArgs(1),
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(statusCmd)
}</span>

func statusRun(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        executionID := args[0]
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewStatusService(c, NewOutputWrapper())
        if err = service.DisplayStatus(cmd.Context(), executionID); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// StatusService handles status display logic
type StatusService struct {
        client client.Interface
        output OutputInterface
}

// NewStatusService creates a new StatusService with the provided dependencies
func NewStatusService(apiClient client.Interface, outputter OutputInterface) *StatusService <span class="cov8" title="1">{
        return &amp;StatusService{
                client: apiClient,
                output: outputter,
        }
}</span>

// DisplayStatus retrieves and displays the status of an execution
func (s *StatusService) DisplayStatus(ctx context.Context, executionID string) error <span class="cov8" title="1">{
        status, err := s.client.GetExecutionStatus(ctx, executionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get status: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.KeyValue("Execution ID", status.ExecutionID)
        s.output.KeyValue("Status", status.Status)
        s.output.KeyValue("Started At", status.StartedAt.Format(time.DateTime))
        if status.CompletedAt != nil </span><span class="cov8" title="1">{
                s.output.KeyValue("Completed At", status.CompletedAt.Format(time.DateTime))
        }</span>
        <span class="cov8" title="1">if status.ExitCode != nil </span><span class="cov8" title="1">{
                s.output.KeyValue("Exit Code", fmt.Sprintf("%d", *status.ExitCode))
        }</span>
        <span class="cov8" title="1">s.output.Blank()
        s.output.Successf("Status retrieved successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "runvoy/internal/api"
        "runvoy/internal/client"
        "runvoy/internal/constants"
        "runvoy/internal/output"

        "github.com/spf13/cobra"
)

var listUsersCmd = &amp;cobra.Command{
        Use:     "list",
        Short:   "List all users",
        Long:    `List all users in the system with their basic information`,
        Example: fmt.Sprintf(`  - %s users list`, constants.ProjectName),
        Run:     runListUsers,
        PostRun: func(_ *cobra.Command, _ []string) <span class="cov0" title="0">{
                output.Blank()
        }</span>,
}

func init() <span class="cov8" title="1">{
        usersCmd.AddCommand(listUsersCmd)
}</span>

func runListUsers(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>

        <span class="cov0" title="0">c := client.New(cfg, slog.Default())
        service := NewUsersService(c, NewOutputWrapper())
        if err = service.ListUsers(cmd.Context()); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

var revokeUserCmd = &amp;cobra.Command{
        Use:   "revoke &lt;email&gt;",
        Short: "Revoke a user's API key",
        Run:   runRevokeUser,
        Args:  cobra.ExactArgs(1),
}

func runRevokeUser(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>
        <span class="cov0" title="0">email := args[0]

        c := client.New(cfg, slog.Default())
        service := NewUsersService(c, NewOutputWrapper())
        if err = service.RevokeUser(cmd.Context(), email); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

func init() <span class="cov8" title="1">{
        usersCmd.AddCommand(revokeUserCmd)
}</span>

var usersCmd = &amp;cobra.Command{
        Use:   "users",
        Short: "User management commands",
}

var createUserCmd = &amp;cobra.Command{
        Use:   "create &lt;email&gt;",
        Short: "Create a new user",
        Long:  `Create a new user with the given email`,
        Example: fmt.Sprintf(`  - %s users create alice@example.com
  - %s users create bob@another-example.com`, constants.ProjectName, constants.ProjectName),
        Run:  runCreateUser,
        Args: cobra.ExactArgs(1),
}

func init() <span class="cov8" title="1">{
        usersCmd.AddCommand(createUserCmd)
        rootCmd.AddCommand(usersCmd)
}</span>

func runCreateUser(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        cfg, err := getConfigFromContext(cmd)
        if err != nil </span><span class="cov0" title="0">{
                output.Errorf("failed to load configuration: %v", err)
                return
        }</span>
        <span class="cov0" title="0">email := args[0]

        c := client.New(cfg, slog.Default())
        service := NewUsersService(c, NewOutputWrapper())
        if err = service.CreateUser(cmd.Context(), email); err != nil </span><span class="cov0" title="0">{
                output.Errorf(err.Error())
        }</span>
}

// UsersService handles user management logic
type UsersService struct {
        client client.Interface
        output OutputInterface
}

// NewUsersService creates a new UsersService with the provided dependencies
func NewUsersService(apiClient client.Interface, outputter OutputInterface) *UsersService <span class="cov8" title="1">{
        return &amp;UsersService{
                client: apiClient,
                output: outputter,
        }
}</span>

// CreateUser creates a new user with the given email
func (s *UsersService) CreateUser(ctx context.Context, email string) error <span class="cov8" title="1">{
        s.output.Infof("Creating user with email %s...", email)

        resp, err := s.client.CreateUser(ctx, api.CreateUserRequest{
                Email: email,
        })
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("User created successfully")
        s.output.KeyValue("Email", resp.User.Email)
        s.output.KeyValue("Claim Token", resp.ClaimToken)
        s.output.Blank()
        s.output.Infof(
                "Share this command with the user =&gt; %s claim %s",
                s.output.Bold(constants.ProjectName),
                s.output.Bold(resp.ClaimToken),
        )
        s.output.Blank()
        s.output.Warningf("â±  Token expires in 15 minutes")
        s.output.Warningf("ðŸ‘  Can only be viewed once")
        return nil</span>
}

// ListUsers lists all users and displays them in a table format
func (s *UsersService) ListUsers(ctx context.Context) error <span class="cov8" title="1">{
        s.output.Infof("Listing usersâ€¦")

        resp, err := s.client.ListUsers(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to list users: %w", err)
        }</span>

        <span class="cov8" title="1">if len(resp.Users) == 0 </span><span class="cov8" title="1">{
                s.output.Blank()
                s.output.Warningf("No users found")
                return nil
        }</span>

        <span class="cov8" title="1">rows := s.formatUsers(resp.Users)

        s.output.Blank()
        s.output.Table(
                []string{
                        "Email",
                        "Status",
                        "Created (UTC)",
                        "Last Used (UTC)",
                },
                rows,
        )
        s.output.Blank()
        s.output.Successf("Users listed successfully")
        return nil</span>
}

// RevokeUser revokes a user's API key
func (s *UsersService) RevokeUser(ctx context.Context, email string) error <span class="cov8" title="1">{
        s.output.Infof("Revoking user with email %s...", email)

        resp, err := s.client.RevokeUser(ctx, api.RevokeUserRequest{
                Email: email,
        })
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to revoke user: %w", err)
        }</span>

        <span class="cov8" title="1">s.output.Successf("User revoked successfully")
        s.output.KeyValue("Email", resp.Email)
        return nil</span>
}

// formatUsers formats user data into table rows
func (s *UsersService) formatUsers(users []*api.User) [][]string <span class="cov8" title="1">{
        rows := make([][]string, 0, len(users))
        for _, u := range users </span><span class="cov8" title="1">{
                createdAt := u.CreatedAt.UTC().Format(time.DateTime)

                lastUsed := "Never"
                if !u.LastUsed.IsZero() </span><span class="cov8" title="1">{
                        lastUsed = u.LastUsed.UTC().Format(time.DateTime)
                }</span>

                <span class="cov8" title="1">status := "Active"
                if u.Revoked </span><span class="cov8" title="1">{
                        status = "Revoked"
                }</span>

                <span class="cov8" title="1">rows = append(rows, []string{
                        s.output.Bold(u.Email),
                        status,
                        createdAt,
                        lastUsed,
                })</span>
        }
        <span class="cov8" title="1">return rows</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "log/slog"
        "runvoy/internal/client"
        "runvoy/internal/constants"
        "runvoy/internal/output"

        "github.com/spf13/cobra"
)

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Show the version of the CLI",
        Run: func(cmd *cobra.Command, _ []string) <span class="cov0" title="0">{
                output.KeyValue("CLI version", *constants.GetVersion())

                cfg, err := getConfigFromContext(cmd)
                if err != nil </span><span class="cov0" title="0">{
                        output.Fatalf("failed to load configuration: %v", err)
                }</span>

                <span class="cov0" title="0">client := client.New(cfg, slog.Default())
                health, err := client.GetHealth(cmd.Context())
                if err != nil </span><span class="cov0" title="0">{
                        output.Errorf(err.Error())
                        return
                }</span>

                <span class="cov0" title="0">output.KeyValue("Backend version", health.Version)</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package main implements the runvoy CLI tool.
// It provides commands for managing users and running remote commands.
package main

import "runvoy/cmd/runvoy/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package aws

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "slices"
        "sort"

        "runvoy/internal/api"
        "runvoy/internal/constants"
        appErrors "runvoy/internal/errors"
        "runvoy/internal/logger"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs"
        cwlTypes "github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs/types"
)

// FetchLogsByExecutionID queries CloudWatch Logs for events associated with the ECS task ID
// Returns an indexed slice of LogEvent sorted by timestamp.
func FetchLogsByExecutionID(ctx context.Context, cfg *Config, executionID string) ([]api.LogEvent, error) <span class="cov0" title="0">{
        if cfg == nil || cfg.LogGroup == "" </span><span class="cov0" title="0">{
                return nil, appErrors.ErrInternalError("CloudWatch Logs group not configured", nil)
        }</span>
        <span class="cov0" title="0">if executionID == "" </span><span class="cov0" title="0">{
                return nil, appErrors.ErrBadRequest("executionID is required", nil)
        }</span>

        <span class="cov0" title="0">awsCfg, err := awsConfig.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, appErrors.ErrInternalError("failed to load AWS configuration", err)
        }</span>
        <span class="cov0" title="0">cwl := cloudwatchlogs.NewFromConfig(awsCfg)
        stream := fmt.Sprintf("task/%s/%s", constants.RunnerContainerName, executionID)
        reqLogger := logger.DeriveRequestLogger(ctx, slog.Default())

        if verifyErr := verifyLogStreamExists(ctx, cwl, cfg.LogGroup, stream, executionID, reqLogger); verifyErr != nil </span><span class="cov0" title="0">{
                return nil, verifyErr
        }</span>

        <span class="cov0" title="0">reqLogger.Debug("calling external service", "context", map[string]string{
                "operation":   "CloudWatchLogs.GetLogEvents",
                "logGroup":    cfg.LogGroup,
                "logStream":   stream,
                "executionID": executionID,
                "paginated":   "true",
        })

        var events []api.LogEvent
        events, err = getAllLogEvents(ctx, cwl, cfg.LogGroup, stream)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">reqLogger.Debug("log events fetched successfully", "context", map[string]int{
                "events_count": len(events),
        })

        sort.SliceStable(events, func(i, j int) bool </span><span class="cov0" title="0">{ return events[i].Timestamp &lt; events[j].Timestamp }</span>)
        <span class="cov0" title="0">for i := range events </span><span class="cov0" title="0">{
                events[i].Line = i + 1
        }</span>
        <span class="cov0" title="0">return events, nil</span>
}

// verifyLogStreamExists checks if the log stream exists and returns an error if it doesn't
func verifyLogStreamExists(
        ctx context.Context,
        cwl *cloudwatchlogs.Client,
        logGroup, stream, executionID string,
        reqLogger *slog.Logger,
) error <span class="cov0" title="0">{
        describeLogArgs := []any{
                "operation", "CloudWatchLogs.DescribeLogStreams",
                "logGroup", logGroup,
                "streamPrefix", stream,
                "executionID", executionID,
        }
        describeLogArgs = append(describeLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(describeLogArgs))

        lsOut, err := cwl.DescribeLogStreams(ctx, &amp;cloudwatchlogs.DescribeLogStreamsInput{
                LogGroupName:        aws.String(logGroup),
                LogStreamNamePrefix: aws.String(stream),
                Limit:               aws.Int32(constants.CloudWatchLogsDescribeLimit),
        })
        if err != nil </span><span class="cov0" title="0">{
                return appErrors.ErrInternalError("failed to describe log streams", err)
        }</span>

        <span class="cov0" title="0">if !slices.ContainsFunc(lsOut.LogStreams, func(s cwlTypes.LogStream) bool </span><span class="cov0" title="0">{
                return aws.ToString(s.LogStreamName) == stream
        }</span>) <span class="cov0" title="0">{
                return appErrors.ErrNotFound(fmt.Sprintf("log stream '%s' does not exist yet", stream), nil)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getAllLogEvents paginates through CloudWatch Logs GetLogEvents to collect all events
// for the provided log group and stream. It returns the aggregated events or an error.
func getAllLogEvents(ctx context.Context,
        cwl *cloudwatchlogs.Client, logGroup string, stream string) ([]api.LogEvent, error) <span class="cov0" title="0">{
        var events []api.LogEvent
        var nextToken *string
        pageCount := 0
        for </span><span class="cov0" title="0">{
                pageCount++

                out, err := cwl.GetLogEvents(ctx, &amp;cloudwatchlogs.GetLogEventsInput{
                        LogGroupName:  &amp;logGroup,
                        LogStreamName: &amp;stream,
                        NextToken:     nextToken,
                        StartFromHead: aws.Bool(true),
                        Limit:         aws.Int32(constants.CloudWatchLogsEventsLimit),
                })

                if err != nil </span><span class="cov0" title="0">{
                        var rte *cwlTypes.ResourceNotFoundException
                        if errors.As(err, &amp;rte) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return nil, appErrors.ErrInternalError("failed to get log events", err)</span>
                }
                <span class="cov0" title="0">for _, e := range out.Events </span><span class="cov0" title="0">{
                        events = append(events, api.LogEvent{
                                Timestamp: aws.ToInt64(e.Timestamp),
                                Message:   aws.ToString(e.Message),
                        })
                }</span>
                <span class="cov0" title="0">if out.NextForwardToken == nil || (nextToken != nil &amp;&amp; *out.NextForwardToken == *nextToken) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">nextToken = out.NextForwardToken</span>
        }
        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package aws provides AWS-specific implementations for runvoy.
// It handles ECS task execution and AWS service integration.
package aws

import (
        "context"
        "fmt"
        "log/slog"
        "slices"
        "strconv"
        "strings"
        "time"

        "runvoy/internal/api"
        "runvoy/internal/constants"
        appErrors "runvoy/internal/errors"
        "runvoy/internal/logger"

        awsStd "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/ecs"
        ecsTypes "github.com/aws/aws-sdk-go-v2/service/ecs/types"
)

// Config holds AWS-specific execution configuration.
type Config struct {
        ECSCluster      string
        TaskDefinition  string
        Subnet1         string
        Subnet2         string
        SecurityGroup   string
        LogGroup        string
        TaskRoleARN     string
        TaskExecRoleARN string
        Region          string
}

// Runner implements app.Runner for AWS ECS Fargate.
type Runner struct {
        ecsClient *ecs.Client
        cfg       *Config
        logger    *slog.Logger
}

// NewRunner creates a new AWS ECS runner with the provided configuration.
func NewRunner(ecsClient *ecs.Client, cfg *Config, log *slog.Logger) *Runner <span class="cov0" title="0">{
        return &amp;Runner{ecsClient: ecsClient, cfg: cfg, logger: log}
}</span>

// FetchLogsByExecutionID returns CloudWatch log events for the given execution ID.
func (e *Runner) FetchLogsByExecutionID(ctx context.Context, executionID string) ([]api.LogEvent, error) <span class="cov0" title="0">{
        return FetchLogsByExecutionID(ctx, e.cfg, executionID)
}</span>

// buildSidecarContainerCommand constructs the shell command for the sidecar container.
// It handles .env file creation from user environment variables and git repository cloning.
func buildSidecarContainerCommand(hasGitRepo bool) []string <span class="cov0" title="0">{
        commands := []string{"set -e"}

        // Create .env file from user environment variables (if any)
        commands = append(commands,
                "if env | grep -q '^RUNVOY_USER_'; then",
                fmt.Sprintf("  echo '### %s sidecar: Creating .env file from user environment variables'", constants.ProjectName),
                "  ENV_FILE_PATH=\"${RUNVOY_SHARED_VOLUME_PATH}/.env\"",
                "  env | grep '^RUNVOY_USER_' | while IFS='=' read -r key value; do",
                "    actual_key=\"${key#RUNVOY_USER_}\"",
                "    echo \"${actual_key}=${value}\" &gt;&gt; \"${ENV_FILE_PATH}\"",
                "  done",
                "  if [ -f \"${ENV_FILE_PATH}\" ]; then",
                fmt.Sprintf(
                        "    echo '### %s sidecar: .env file created with' "+
                                "$(wc -l &lt; \"${ENV_FILE_PATH}\") 'variables at' \"${ENV_FILE_PATH}\"",
                        constants.ProjectName,
                ),
                "  else",
                fmt.Sprintf("    echo '### %s sidecar: No .env file created'", constants.ProjectName),
                "  fi",
                "else",
                fmt.Sprintf(
                        "  echo '### %s sidecar: No RUNVOY_USER_* variables found, skipping .env creation'",
                        constants.ProjectName,
                ),
                "fi",
        )

        // Git repository cloning logic (if specified)
        if hasGitRepo </span><span class="cov0" title="0">{
                commands = append(commands,
                        "apk add --no-cache git",
                        "GIT_REF=${GIT_REF:-main}",
                        "CLONE_PATH=${RUNVOY_SHARED_VOLUME_PATH}/repo",
                        fmt.Sprintf("echo '### %s sidecar: Cloning ${GIT_REPO} (ref: ${GIT_REF})'", constants.ProjectName),
                        "git clone --depth 1 --branch \"${GIT_REF}\" \"${GIT_REPO}\" \"${CLONE_PATH}\"",
                        fmt.Sprintf("echo '### %s sidecar: Clone completed successfully'", constants.ProjectName),
                        "if [ -f \"${RUNVOY_SHARED_VOLUME_PATH}/.env\" ]; then",
                        "  cp \"${RUNVOY_SHARED_VOLUME_PATH}/.env\" \"${CLONE_PATH}/.env\"",
                        fmt.Sprintf("  echo '### %s sidecar: .env file copied to repo directory'", constants.ProjectName),
                        "fi",
                        "ls -la \"${CLONE_PATH}\"",
                )
        }</span> else<span class="cov0" title="0"> {
                // If no GIT_REPO is specified, just exit successfully
                commands = append(commands,
                        fmt.Sprintf("echo '### %s sidecar: No git repository specified, exiting'", constants.ProjectName),
                )
        }</span>

        <span class="cov0" title="0">commands = append(commands,
                fmt.Sprintf("echo '### %s sidecar: Sidecar completed successfully'", constants.ProjectName),
        )

        return []string{"/bin/sh", "-c", strings.Join(commands, "\n")}</span>
}

type gitRepoInfo struct {
        RepoURL  *string
        RepoRef  *string
        RepoPath *string
}

// buildMainContainerCommand constructs the shell command for the main runner container.
// It adds logging statements and optionally changes to the git repo working directory.
func buildMainContainerCommand(req *api.ExecutionRequest, requestID, image string, repo *gitRepoInfo) []string <span class="cov0" title="0">{
        commands := []string{
                fmt.Sprintf("printf '### %s runner execution started by requestID =&gt; %s\\n'",
                        constants.ProjectName, requestID),
                fmt.Sprintf("printf '### Docker image =&gt; %s\\n'", image),
        }

        if repo != nil </span><span class="cov0" title="0">{
                workDir := constants.SharedVolumePath + "/repo"
                if *repo.RepoPath != "" &amp;&amp; *repo.RepoPath != "." </span><span class="cov0" title="0">{
                        workDir = workDir + "/" + strings.TrimPrefix(*repo.RepoPath, "/")
                }</span>
                <span class="cov0" title="0">commands = append(commands,
                        fmt.Sprintf("cd %s", workDir),
                        fmt.Sprintf("printf '### Checked out repo =&gt; %s (ref: %s) (path: %s)\\n'",
                                *repo.RepoURL, *repo.RepoRef, *repo.RepoPath),
                        fmt.Sprintf("printf '### Working directory =&gt; %s\\n'", workDir),
                )</span>
        }

        <span class="cov0" title="0">commands = append(commands,
                fmt.Sprintf("printf '### %s command =&gt; %s\\n'", constants.ProjectName, req.Command),
                req.Command,
        )

        return []string{"/bin/sh", "-c", strings.Join(commands, " &amp;&amp; ")}</span>
}

// StartTask triggers an ECS Fargate task and returns identifiers.
func (e *Runner) StartTask( //nolint: funlen
        ctx context.Context, userEmail string, req *api.ExecutionRequest) (string, *time.Time, error) <span class="cov0" title="0">{
        if e.ecsClient == nil </span><span class="cov0" title="0">{
                return "", nil, appErrors.ErrInternalError("ECS cli endpoint not configured", nil)
        }</span>

        <span class="cov0" title="0">reqLogger := logger.DeriveRequestLogger(ctx, e.logger)
        imageToUse := req.Image

        if imageToUse == "" </span><span class="cov0" title="0">{
                defaultImage, err := GetDefaultImage(ctx, e.ecsClient, reqLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, appErrors.ErrInternalError("failed to query default image", err)
                }</span>
                <span class="cov0" title="0">if defaultImage == "" </span><span class="cov0" title="0">{
                        return "", nil, appErrors.ErrBadRequest("no image specified and no default image configured", nil)
                }</span>
                <span class="cov0" title="0">imageToUse = defaultImage
                reqLogger.Debug("using default image", "image", imageToUse)</span>
        }

        <span class="cov0" title="0">taskDefARN, err := GetTaskDefinitionForImage(ctx, e.ecsClient, imageToUse, reqLogger)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, appErrors.ErrBadRequest("image not registered", err)
        }</span>

        <span class="cov0" title="0">reqLogger.Debug("using task definition for image", "context", map[string]string{
                "image": imageToUse,
                "arn":   taskDefARN,
        })

        hasGitRepo := req.GitRepo != ""
        requestID := logger.GetRequestID(ctx)
        envVars := []ecsTypes.KeyValuePair{
                {Name: awsStd.String("RUNVOY_COMMAND"), Value: awsStd.String(req.Command)},
        }
        for key, value := range req.Env </span><span class="cov0" title="0">{
                envVars = append(envVars, ecsTypes.KeyValuePair{
                        Name:  awsStd.String(key),
                        Value: awsStd.String(value),
                })
        }</span>

        <span class="cov0" title="0">sidecarEnv := []ecsTypes.KeyValuePair{
                {Name: awsStd.String("RUNVOY_SHARED_VOLUME_PATH"),
                        Value: awsStd.String(constants.SharedVolumePath)},
        }

        for key, value := range req.Env </span><span class="cov0" title="0">{
                sidecarEnv = append(sidecarEnv, ecsTypes.KeyValuePair{
                        Name:  awsStd.String(key),
                        Value: awsStd.String(value),
                })
        }</span>

        <span class="cov0" title="0">if hasGitRepo </span><span class="cov0" title="0">{
                gitRef := req.GitRef
                if gitRef == "" </span><span class="cov0" title="0">{
                        gitRef = "main"
                }</span>
                <span class="cov0" title="0">sidecarEnv = append(sidecarEnv,
                        ecsTypes.KeyValuePair{Name: awsStd.String("GIT_REPO"), Value: awsStd.String(req.GitRepo)},
                        ecsTypes.KeyValuePair{Name: awsStd.String("GIT_REF"), Value: awsStd.String(gitRef)},
                )
                reqLogger.Debug("configured sidecar for git cloning",
                        "gitRepo", req.GitRepo,
                        "gitRef", gitRef)</span>
        } else<span class="cov0" title="0"> {
                sidecarEnv = append(sidecarEnv,
                        ecsTypes.KeyValuePair{Name: awsStd.String("GIT_REPO"), Value: awsStd.String("")},
                )
                reqLogger.Debug("sidecar configured without git (will exit 0)")
        }</span>

        <span class="cov0" title="0">var repo *gitRepoInfo
        if hasGitRepo </span><span class="cov0" title="0">{
                repo = &amp;gitRepoInfo{
                        RepoURL:  awsStd.String(req.GitRepo),
                        RepoRef:  awsStd.String(req.GitRef),
                        RepoPath: awsStd.String(req.GitPath),
                }
        }</span>
        <span class="cov0" title="0">containerOverrides := []ecsTypes.ContainerOverride{
                {
                        Name:        awsStd.String(constants.SidecarContainerName),
                        Command:     buildSidecarContainerCommand(hasGitRepo),
                        Environment: sidecarEnv,
                },
                {
                        Name:        awsStd.String(constants.RunnerContainerName),
                        Command:     buildMainContainerCommand(req, requestID, imageToUse, repo),
                        Environment: envVars,
                },
        }

        tags := []ecsTypes.Tag{
                {Key: awsStd.String("UserEmail"), Value: awsStd.String(userEmail)},
        }
        if hasGitRepo </span><span class="cov0" title="0">{
                tags = append(tags, ecsTypes.Tag{
                        Key:   awsStd.String("HasGitRepo"),
                        Value: awsStd.String("true"),
                })
        }</span>

        <span class="cov0" title="0">runTaskInput := &amp;ecs.RunTaskInput{
                Cluster:        awsStd.String(e.cfg.ECSCluster),
                TaskDefinition: awsStd.String(taskDefARN),
                LaunchType:     ecsTypes.LaunchTypeFargate,
                Overrides: &amp;ecsTypes.TaskOverride{
                        ContainerOverrides: containerOverrides,
                },
                NetworkConfiguration: &amp;ecsTypes.NetworkConfiguration{
                        AwsvpcConfiguration: &amp;ecsTypes.AwsVpcConfiguration{
                                Subnets:        []string{e.cfg.Subnet1, e.cfg.Subnet2},
                                SecurityGroups: []string{e.cfg.SecurityGroup},
                                AssignPublicIp: ecsTypes.AssignPublicIpEnabled,
                        },
                },
                Tags: tags,
        }

        logArgs := []any{
                "operation", "ECS.RunTask",
                "cluster", e.cfg.ECSCluster,
                "taskDefinition", taskDefARN,
                "image", imageToUse,
                "containerCount", len(containerOverrides),
                "userEmail", userEmail,
                "hasGitRepo", hasGitRepo,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        var runTaskOutput *ecs.RunTaskOutput
        runTaskOutput, err = e.ecsClient.RunTask(ctx, runTaskInput)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, appErrors.ErrInternalError("failed to start ECS task", err)
        }</span>
        <span class="cov0" title="0">if len(runTaskOutput.Tasks) == 0 </span><span class="cov0" title="0">{
                return "", nil, appErrors.ErrInternalError("no tasks were started", nil)
        }</span>

        <span class="cov0" title="0">task := runTaskOutput.Tasks[0]
        taskARN := awsStd.ToString(task.TaskArn)
        executionIDParts := strings.Split(taskARN, "/")
        executionID := executionIDParts[len(executionIDParts)-1]
        createdAt := task.CreatedAt

        reqLogger.Debug("task started", "task", map[string]string{
                "taskARN":     taskARN,
                "executionID": executionID,
        })

        tagLogArgs := []any{
                "operation", "ECS.TagResource",
                "taskARN", taskARN,
                "executionID", executionID,
                "createdAt", createdAt,
        }
        tagLogArgs = append(tagLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(tagLogArgs))

        _, tagErr := e.ecsClient.TagResource(ctx, &amp;ecs.TagResourceInput{
                ResourceArn: awsStd.String(taskARN),
                Tags:        []ecsTypes.Tag{{Key: awsStd.String("ExecutionID"), Value: awsStd.String(executionID)}},
        })
        if tagErr != nil </span><span class="cov0" title="0">{
                reqLogger.Warn(
                        "failed to add ExecutionID tag to task",
                        "error", tagErr,
                        "taskARN", taskARN,
                        "executionID", executionID)
        }</span>

        <span class="cov0" title="0">return executionID, createdAt, nil</span>
}

// RegisterImage registers a Docker image and creates the corresponding task definition.
// isDefault: if true, explicitly set as default.
// If nil or false, becomes default only if no default exists (first image behavior).
func (e *Runner) RegisterImage(ctx context.Context, image string, isDefault *bool) error <span class="cov0" title="0">{
        if e.ecsClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ECS client not configured")
        }</span>

        <span class="cov0" title="0">reqLogger := logger.DeriveRequestLogger(ctx, e.logger)

        region := e.cfg.Region
        if region == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("AWS region not configured")
        }</span>

        <span class="cov0" title="0">err := RegisterTaskDefinitionForImage(ctx, e.ecsClient, e.cfg, image, isDefault, region, reqLogger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task definition: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListImages lists all registered Docker images.
func (e *Runner) ListImages(ctx context.Context) ([]api.ImageInfo, error) <span class="cov0" title="0">{
        if e.ecsClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ECS client not configured")
        }</span>

        <span class="cov0" title="0">reqLogger := logger.DeriveRequestLogger(ctx, e.logger)
        reqLogger.Debug("calling external service", "context", map[string]string{
                "operation": "ECS.ListTaskDefinitions",
                "status":    "active",
                "paginated": "true",
        })
        taskDefArns, err := listTaskDefinitionsByPrefix(ctx, e.ecsClient, constants.TaskDefinitionFamilyPrefix+"-")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := collectImageInfos(ctx, e.ecsClient, taskDefArns, reqLogger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// describeTaskDef describes a task definition and returns it.
func describeTaskDef(
        ctx context.Context, ecsClient *ecs.Client, taskDefARN string, reqLogger *slog.Logger,
) (*ecsTypes.TaskDefinition, error) <span class="cov0" title="0">{
        descOutput, err := ecsClient.DescribeTaskDefinition(ctx, &amp;ecs.DescribeTaskDefinitionInput{
                TaskDefinition: awsStd.String(taskDefARN),
        })
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("failed to describe task definition", "context", map[string]string{
                        "operation": "ECS.DescribeTaskDefinition",
                        "arn":       taskDefARN,
                        "error":     err.Error(),
                })
                return nil, appErrors.ErrInternalError("failed to describe task definition", err)
        }</span>
        <span class="cov0" title="0">if descOutput.TaskDefinition == nil </span><span class="cov0" title="0">{
                return nil, appErrors.ErrInternalError("task definition not found", nil)
        }</span>
        <span class="cov0" title="0">return descOutput.TaskDefinition, nil</span>
}

// extractImageFromTaskDef extracts the runner container image from a task definition.
func extractImageFromTaskDef(taskDef *ecsTypes.TaskDefinition, reqLogger *slog.Logger) string <span class="cov0" title="0">{
        familyName := awsStd.ToString(taskDef.Family)
        for i := range taskDef.ContainerDefinitions </span><span class="cov0" title="0">{
                container := &amp;taskDef.ContainerDefinitions[i]
                if container.Name != nil &amp;&amp; *container.Name == constants.RunnerContainerName &amp;&amp; container.Image != nil </span><span class="cov0" title="0">{
                        return *container.Image
                }</span>
        }
        <span class="cov0" title="0">reqLogger.Debug("no runner container found in task definition", "container", map[string]string{
                "family":          familyName,
                "container_count": fmt.Sprintf("%d", len(taskDef.ContainerDefinitions)),
        })
        return ""</span>
}

// checkIsDefaultTaskDef checks if a task definition is marked as default.
func checkIsDefaultTaskDef(ctx context.Context, ecsClient *ecs.Client, taskDefARN string) bool <span class="cov0" title="0">{
        tagsOutput, err := ecsClient.ListTagsForResource(ctx, &amp;ecs.ListTagsForResourceInput{
                ResourceArn: awsStd.String(taskDefARN),
        })
        if err != nil || tagsOutput == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, tag := range tagsOutput.Tags </span><span class="cov0" title="0">{
                if tag.Key != nil &amp;&amp; tag.Value != nil &amp;&amp;
                        *tag.Key == constants.TaskDefinitionIsDefaultTagKey &amp;&amp;
                        *tag.Value == constants.TaskDefinitionIsDefaultTagValue </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// collectImageInfos iterates described ECS task definitions and extracts unique runner image infos.
func collectImageInfos(
        ctx context.Context, ecsClient *ecs.Client, taskDefArns []string, reqLogger *slog.Logger,
) ([]api.ImageInfo, error) <span class="cov0" title="0">{ //nolint:cyclop
        result := make([]api.ImageInfo, 0)
        seenImages := make(map[string]bool)

        for _, taskDefARN := range taskDefArns </span><span class="cov0" title="0">{
                taskDef, err := describeTaskDef(ctx, ecsClient, taskDefARN, reqLogger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">image := extractImageFromTaskDef(taskDef, reqLogger)
                if image == "" || seenImages[image] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">seenImages[image] = true
                isDefault := checkIsDefaultTaskDef(ctx, ecsClient, taskDefARN)

                result = append(result, api.ImageInfo{
                        Image:              image,
                        TaskDefinitionARN:  awsStd.ToString(taskDef.TaskDefinitionArn),
                        TaskDefinitionName: awsStd.ToString(taskDef.Family),
                        IsDefault:          awsStd.Bool(isDefault),
                })</span>
        }

        <span class="cov0" title="0">for _, imageInfo := range result </span><span class="cov0" title="0">{
                reqLogger.Debug("found runner container image", "context", map[string]string{
                        "family":         imageInfo.TaskDefinitionName,
                        "container_name": constants.RunnerContainerName,
                        "image":          imageInfo.Image,
                        "isDefault":      strconv.FormatBool(awsStd.ToBool(imageInfo.IsDefault)),
                })
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// RemoveImage removes a Docker image and deregisters its task definitions.
func (e *Runner) RemoveImage(ctx context.Context, image string) error <span class="cov0" title="0">{
        if e.ecsClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ECS client not configured")
        }</span>

        <span class="cov0" title="0">reqLogger := logger.DeriveRequestLogger(ctx, e.logger)

        if err := DeregisterTaskDefinitionsForImage(ctx, e.ecsClient, image, reqLogger); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove image: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// findTaskARNByExecutionID finds the task ARN for a given execution ID by checking both running and stopped tasks.
func (e *Runner) findTaskARNByExecutionID(
        ctx context.Context, executionID string, reqLogger *slog.Logger,
) (string, error) <span class="cov0" title="0">{
        listLogArgs := []any{
                "operation", "ECS.ListTasks",
                "cluster", e.cfg.ECSCluster,
                "desiredStatus", "RUNNING",
                "executionID", executionID,
        }
        listLogArgs = append(listLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(listLogArgs))

        listOutput, err := e.ecsClient.ListTasks(ctx, &amp;ecs.ListTasksInput{
                Cluster:       awsStd.String(e.cfg.ECSCluster),
                DesiredStatus: ecsTypes.DesiredStatusRunning,
        })
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Debug("failed to list tasks", "error", err, "executionID", executionID)
                return "", appErrors.ErrInternalError("failed to list tasks", err)
        }</span>

        <span class="cov0" title="0">taskARN := extractTaskARNFromList(listOutput.TaskArns, executionID)
        if taskARN != "" </span><span class="cov0" title="0">{
                return taskARN, nil
        }</span>

        // If not found in running tasks, check stopped tasks
        <span class="cov0" title="0">listStoppedLogArgs := []any{
                "operation", "ECS.ListTasks",
                "cluster", e.cfg.ECSCluster,
                "desiredStatus", "STOPPED",
                "executionID", executionID,
        }
        listStoppedLogArgs = append(listStoppedLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(listStoppedLogArgs))

        listStoppedOutput, err := e.ecsClient.ListTasks(ctx, &amp;ecs.ListTasksInput{
                Cluster:       awsStd.String(e.cfg.ECSCluster),
                DesiredStatus: ecsTypes.DesiredStatusStopped,
        })
        if err == nil </span><span class="cov0" title="0">{
                taskARN = extractTaskARNFromList(listStoppedOutput.TaskArns, executionID)
        }</span>

        <span class="cov0" title="0">if taskARN == "" </span><span class="cov0" title="0">{
                reqLogger.Error("task not found", "executionID", executionID)
                return "", appErrors.ErrNotFound("task not found", nil)
        }</span>

        <span class="cov0" title="0">return taskARN, nil</span>
}

// extractTaskARNFromList finds the task ARN that matches the execution ID from a list of task ARNs.
func extractTaskARNFromList(taskArns []string, executionID string) string <span class="cov0" title="0">{
        for _, arn := range taskArns </span><span class="cov0" title="0">{
                parts := strings.Split(arn, "/")
                if len(parts) &gt; 0 &amp;&amp; parts[len(parts)-1] == executionID </span><span class="cov0" title="0">{
                        return arn
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// validateTaskStatusForKill validates that a task is in a state that can be terminated.
func validateTaskStatusForKill(currentStatus string) error <span class="cov0" title="0">{
        terminatedStatuses := []string{
                string(constants.EcsStatusStopped),
                string(constants.EcsStatusStopping),
                string(constants.EcsStatusDeactivating),
        }
        for _, status := range terminatedStatuses </span><span class="cov0" title="0">{
                if currentStatus == status </span><span class="cov0" title="0">{
                        return appErrors.ErrBadRequest(
                                "task is already terminated or terminating",
                                fmt.Errorf("task status: %s", currentStatus))
                }</span>
        }

        <span class="cov0" title="0">taskRunnableStatuses := []string{
                string(constants.EcsStatusRunning),
                string(constants.EcsStatusActivating),
        }
        if !slices.Contains(taskRunnableStatuses, string(constants.EcsStatus(currentStatus))) </span><span class="cov0" title="0">{
                return appErrors.ErrBadRequest(
                        "task cannot be terminated in current state",
                        fmt.Errorf(
                                "task status: %s, expected: %s",
                                currentStatus,
                                strings.Join(taskRunnableStatuses, ", ")))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// KillTask terminates an ECS task identified by executionID.
// It checks the task status before termination and only stops tasks that are RUNNING or ACTIVATING.
// Returns an error if the task is already terminated or not found.
//
//nolint:funlen // Complex AWS API orchestration
func (e *Runner) KillTask(ctx context.Context, executionID string) error <span class="cov0" title="0">{
        if e.ecsClient == nil </span><span class="cov0" title="0">{
                return appErrors.ErrInternalError("ECS client not configured", nil)
        }</span>

        <span class="cov0" title="0">reqLogger := logger.DeriveRequestLogger(ctx, e.logger)

        taskARN, err := e.findTaskARNByExecutionID(ctx, executionID, reqLogger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">describeLogArgs := []any{
                "operation", "ECS.DescribeTasks",
                "cluster", e.cfg.ECSCluster,
                "taskARN", taskARN,
                "executionID", executionID,
        }
        describeLogArgs = append(describeLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(describeLogArgs))

        describeOutput, err := e.ecsClient.DescribeTasks(ctx, &amp;ecs.DescribeTasksInput{
                Cluster: awsStd.String(e.cfg.ECSCluster),
                Tasks:   []string{taskARN},
        })
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("failed to describe task", "context", map[string]string{
                        "error":       err.Error(),
                        "executionID": executionID,
                        "taskARN":     taskARN,
                })
                return appErrors.ErrInternalError("failed to describe task", err)
        }</span>

        <span class="cov0" title="0">if len(describeOutput.Tasks) == 0 </span><span class="cov0" title="0">{
                reqLogger.Error("task not found", "context", map[string]string{
                        "executionID": executionID,
                        "taskARN":     taskARN,
                })
                return appErrors.ErrNotFound("task not found", nil)
        }</span>

        <span class="cov0" title="0">task := describeOutput.Tasks[0]
        currentStatus := awsStd.ToString(task.LastStatus)
        reqLogger.Debug("task status check", "executionID", executionID, "status", currentStatus)

        if validateErr := validateTaskStatusForKill(currentStatus); validateErr != nil </span><span class="cov0" title="0">{
                return validateErr
        }</span>

        <span class="cov0" title="0">stopLogArgs := []any{
                "operation", "ECS.StopTask",
                "cluster", e.cfg.ECSCluster,
                "taskARN", taskARN,
                "executionID", executionID,
                "currentStatus", currentStatus,
        }
        stopLogArgs = append(stopLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(stopLogArgs))

        stopOutput, err := e.ecsClient.StopTask(ctx, &amp;ecs.StopTaskInput{
                Cluster: awsStd.String(e.cfg.ECSCluster),
                Task:    awsStd.String(taskARN),
                Reason:  awsStd.String("Terminated by user via kill endpoint"),
        })
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("failed to stop task", "error", err, "executionID", executionID, "taskARN", taskARN)
                return appErrors.ErrInternalError("failed to stop task", err)
        }</span>

        <span class="cov0" title="0">reqLogger.Info(
                "task termination initiated",
                "executionID", executionID,
                "taskARN", awsStd.ToString(stopOutput.Task.TaskArn),
                "previousStatus", currentStatus)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package aws provides AWS-specific implementations for runvoy.
package aws

import (
        "context"
        "fmt"
        "log/slog"
        "regexp"
        "strconv"
        "strings"

        "runvoy/internal/constants"

        awsStd "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/ecs"
        ecsTypes "github.com/aws/aws-sdk-go-v2/service/ecs/types"
)

// SanitizeImageNameForTaskDef converts a Docker image name to a valid ECS task definition family name.
// ECS task definition family names must match: [a-zA-Z0-9_-]+
// Examples:
//   - "hashicorp/terraform:1.6" -&gt; "hashicorp-terraform-1-6"
//   - "myregistry.com/my-image:latest" -&gt; "myregistry-com-my-image-latest"
func SanitizeImageNameForTaskDef(image string) string <span class="cov0" title="0">{
        re := regexp.MustCompile(`[^a-zA-Z0-9_-]`)
        sanitized := re.ReplaceAllString(image, "-")
        re2 := regexp.MustCompile(`-+`)
        sanitized = re2.ReplaceAllString(sanitized, "-")
        sanitized = strings.Trim(sanitized, "-")
        return sanitized
}</span>

// TaskDefinitionFamilyName returns the ECS task definition family name for a given image.
// Format: {TaskDefinitionFamilyPrefix}-{sanitized-image-name}
func TaskDefinitionFamilyName(image string) string <span class="cov0" title="0">{
        sanitized := SanitizeImageNameForTaskDef(image)
        return fmt.Sprintf("%s-%s", constants.TaskDefinitionFamilyPrefix, sanitized)
}</span>

// ExtractImageFromTaskDefFamily extracts the Docker image name from a task definition family name.
// Returns empty string if the family name doesn't match the expected format.
// NOTE: This is approximate - images should be read from container definitions or tags, not family names.
func ExtractImageFromTaskDefFamily(familyName string) string <span class="cov0" title="0">{
        prefix := constants.TaskDefinitionFamilyPrefix + "-"
        if !strings.HasPrefix(familyName, prefix) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">imagePart := strings.TrimPrefix(familyName, prefix)
        return imagePart</span>
}

// listTaskDefinitionsByPrefix lists all active task definitions whose family name starts with the given prefix.
// It handles pagination internally and filters by checking the task definition family name (extracted from ARN).
// This is necessary because the FamilyPrefix parameter in ListTaskDefinitions doesn't work as expected
// for prefix matching - it requires exact family match rather than prefix matching.
func listTaskDefinitionsByPrefix(ctx context.Context, ecsClient *ecs.Client, prefix string) ([]string, error) <span class="cov0" title="0">{
        nextToken := ""
        var taskDefArns []string

        for </span><span class="cov0" title="0">{
                listOutput, err := ecsClient.ListTaskDefinitions(ctx, &amp;ecs.ListTaskDefinitionsInput{
                        Status:    ecsTypes.TaskDefinitionStatusActive,
                        NextToken: awsStd.String(nextToken),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list task definitions: %w", err)
                }</span>

                // taskDefARN format example:
                // arn:aws:ecs:us-east-2:123456789012:task-definition/runvoy-image-alpine-latest:1
                // Extract the family name (last part after "/") and filter by prefix
                <span class="cov0" title="0">for _, taskDefARN := range listOutput.TaskDefinitionArns </span><span class="cov0" title="0">{
                        parts := strings.Split(taskDefARN, "/")
                        if len(parts) &gt; 0 &amp;&amp;
                                strings.HasPrefix(parts[len(parts)-1], prefix) </span><span class="cov0" title="0">{
                                taskDefArns = append(taskDefArns, taskDefARN)
                        }</span>
                }

                <span class="cov0" title="0">if listOutput.NextToken == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">nextToken = *listOutput.NextToken</span>
        }

        <span class="cov0" title="0">return taskDefArns, nil</span>
}

// GetDefaultImage returns the Docker image marked as default (via IsDefault tag).
// Returns empty string if no default image is found.
func GetDefaultImage(
        ctx context.Context,
        ecsClient *ecs.Client,
        logger *slog.Logger,
) (string, error) <span class="cov0" title="0">{
        familyPrefix := constants.TaskDefinitionFamilyPrefix + "-"
        taskDefArns, err := listTaskDefinitionsByPrefix(ctx, ecsClient, familyPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">logger.Debug("calling external service", "context", map[string]string{
                "operation":    "ECS.ListTagsForResource",
                "resourceArns": strings.Join(taskDefArns, ", "),
        })

        for _, taskDefARN := range taskDefArns </span><span class="cov0" title="0">{
                var tagsOutput *ecs.ListTagsForResourceOutput
                tagsOutput, err = ecsClient.ListTagsForResource(ctx, &amp;ecs.ListTagsForResourceInput{
                        ResourceArn: awsStd.String(taskDefARN),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("failed to list tags for task definition", "context", map[string]string{
                                "arn":   taskDefARN,
                                "error": err.Error(),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">isDefault := false
                var dockerImage string
                for _, tag := range tagsOutput.Tags </span><span class="cov0" title="0">{
                        if tag.Key != nil &amp;&amp; tag.Value != nil </span><span class="cov0" title="0">{
                                if *tag.Key == constants.TaskDefinitionIsDefaultTagKey &amp;&amp; *tag.Value == constants.TaskDefinitionIsDefaultTagValue </span><span class="cov0" title="0">{
                                        isDefault = true
                                }</span>
                                <span class="cov0" title="0">if *tag.Key == constants.TaskDefinitionDockerImageTagKey </span><span class="cov0" title="0">{
                                        dockerImage = *tag.Value
                                }</span>
                        }
                }

                <span class="cov0" title="0">if isDefault &amp;&amp; dockerImage != "" </span><span class="cov0" title="0">{
                        return dockerImage, nil
                }</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// unmarkExistingDefaultImages removes the IsDefault tag from all existing task definitions
// that have it. This ensures only one image can be marked as default at a time.
func unmarkExistingDefaultImages(
        ctx context.Context,
        ecsClient *ecs.Client,
        logger *slog.Logger,
) error <span class="cov0" title="0">{
        familyPrefix := constants.TaskDefinitionFamilyPrefix + "-"
        taskDefArns, err := listTaskDefinitionsByPrefix(ctx, ecsClient, familyPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, taskDefARN := range taskDefArns </span><span class="cov0" title="0">{
                var tagsOutput *ecs.ListTagsForResourceOutput
                tagsOutput, err = ecsClient.ListTagsForResource(ctx, &amp;ecs.ListTagsForResourceInput{
                        ResourceArn: awsStd.String(taskDefARN),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to list tags for task definition", "context", map[string]string{
                                "arn":   taskDefARN,
                                "error": err.Error(),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">hasDefaultTag := false
                for _, tag := range tagsOutput.Tags </span><span class="cov0" title="0">{
                        if tag.Key != nil &amp;&amp; *tag.Key == constants.TaskDefinitionIsDefaultTagKey &amp;&amp;
                                tag.Value != nil &amp;&amp; *tag.Value == constants.TaskDefinitionIsDefaultTagValue </span><span class="cov0" title="0">{
                                hasDefaultTag = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if hasDefaultTag </span><span class="cov0" title="0">{
                        _, err = ecsClient.UntagResource(ctx, &amp;ecs.UntagResourceInput{
                                ResourceArn: awsStd.String(taskDefARN),
                                TagKeys:     []string{constants.TaskDefinitionIsDefaultTagKey},
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("failed to remove default tag from task definition", "context", map[string]string{
                                        "arn":    taskDefARN,
                                        "error":  err.Error(),
                                        "tagKey": constants.TaskDefinitionIsDefaultTagKey,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                logger.Info("removed default tag from existing task definition", "arn", taskDefARN)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetTaskDefinitionForImage looks up an existing task definition for the given Docker image.
// Returns an error if the task definition doesn't exist (does not auto-register).
func GetTaskDefinitionForImage(
        ctx context.Context,
        ecsClient *ecs.Client,
        image string,
        logger *slog.Logger,
) (string, error) <span class="cov0" title="0">{
        family := TaskDefinitionFamilyName(image)

        listOutput, err := ecsClient.ListTaskDefinitions(ctx, &amp;ecs.ListTaskDefinitionsInput{
                FamilyPrefix: awsStd.String(family),
                Status:       ecsTypes.TaskDefinitionStatusActive,
                MaxResults:   awsStd.Int32(1),
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list task definitions: %w", err)
        }</span>

        <span class="cov0" title="0">if len(listOutput.TaskDefinitionArns) &gt; 0 </span><span class="cov0" title="0">{
                latestARN := listOutput.TaskDefinitionArns[len(listOutput.TaskDefinitionArns)-1]
                logger.Debug("task definition found", "context", map[string]string{
                        "family": family,
                        "arn":    latestARN,
                })
                return latestARN, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("task definition for image %q not found (family: %s). "+
                "Image must be registered via /api/v1/images/register",
                image, family)</span>
}

// handleDefaultImageTagging handles updating default image tags when registering a new image.
func handleDefaultImageTagging(
        ctx context.Context, ecsClient *ecs.Client, isDefault *bool, existingTaskDefARN string, logger *slog.Logger,
) error <span class="cov0" title="0">{
        if isDefault != nil &amp;&amp; *isDefault </span><span class="cov0" title="0">{
                if err := unmarkExistingDefaultImages(ctx, ecsClient, logger); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to unmark existing default images, proceeding anyway", "error", err)
                }</span>
        } else<span class="cov0" title="0"> if existingTaskDefARN != "" </span><span class="cov0" title="0">{
                _, err := ecsClient.UntagResource(ctx, &amp;ecs.UntagResourceInput{
                        ResourceArn: awsStd.String(existingTaskDefARN),
                        TagKeys:     []string{constants.TaskDefinitionIsDefaultTagKey},
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug(
                                "failed to remove default tag from existing task definition (may not have had it)",
                                "arn", existingTaskDefARN,
                                "error", err,
                        )
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("removed default tag from existing task definition", "arn", existingTaskDefARN)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// updateExistingTaskDefTags updates tags on an existing task definition.
func updateExistingTaskDefTags(
        ctx context.Context, ecsClient *ecs.Client, taskDefARN, image string,
        isDefault *bool, family string, logger *slog.Logger,
) error <span class="cov0" title="0">{
        tags := buildTaskDefinitionTags(image, isDefault)
        _, tagErr := ecsClient.TagResource(ctx, &amp;ecs.TagResourceInput{
                ResourceArn: awsStd.String(taskDefARN),
                Tags:        tags,
        })
        if tagErr != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to tag existing task definition", "context", map[string]string{
                        "arn":   taskDefARN,
                        "error": tagErr.Error(),
                })
                return fmt.Errorf("failed to update tags on existing task definition: %w", tagErr)
        }</span>
        <span class="cov0" title="0">logger.Info("updated tags on existing task definition", "context", map[string]string{
                "family":    family,
                "arn":       taskDefARN,
                "image":     image,
                "isDefault": strconv.FormatBool(isDefault != nil &amp;&amp; *isDefault),
        })
        return nil</span>
}

// getRoleARNsFromExistingTaskDef retrieves task role ARNs from an existing task definition
// if they're not provided in config.
func getRoleARNsFromExistingTaskDef(
        ctx context.Context, ecsClient *ecs.Client, taskExecRoleARN, taskRoleARN string,
) (execRoleARN, roleARN string) <span class="cov0" title="0">{
        if taskExecRoleARN == "" || taskRoleARN == "" </span><span class="cov0" title="0">{
                allFamilies, err := ecsClient.ListTaskDefinitions(ctx, &amp;ecs.ListTaskDefinitionsInput{
                        MaxResults: awsStd.Int32(1),
                })
                if err == nil &amp;&amp; len(allFamilies.TaskDefinitionArns) &gt; 0 </span><span class="cov0" title="0">{
                        var descOutput *ecs.DescribeTaskDefinitionOutput
                        descOutput, err = ecsClient.DescribeTaskDefinition(ctx, &amp;ecs.DescribeTaskDefinitionInput{
                                TaskDefinition: awsStd.String(allFamilies.TaskDefinitionArns[len(allFamilies.TaskDefinitionArns)-1]),
                        })
                        if err == nil &amp;&amp; descOutput.TaskDefinition != nil </span><span class="cov0" title="0">{
                                if taskExecRoleARN == "" &amp;&amp; descOutput.TaskDefinition.ExecutionRoleArn != nil </span><span class="cov0" title="0">{
                                        taskExecRoleARN = awsStd.ToString(descOutput.TaskDefinition.ExecutionRoleArn)
                                }</span>
                                <span class="cov0" title="0">if taskRoleARN == "" &amp;&amp; descOutput.TaskDefinition.TaskRoleArn != nil </span><span class="cov0" title="0">{
                                        taskRoleARN = awsStd.ToString(descOutput.TaskDefinition.TaskRoleArn)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return taskExecRoleARN, taskRoleARN</span>
}

// buildTaskDefinitionTags creates the tags to be applied to a task definition.
func buildTaskDefinitionTags(image string, isDefault *bool) []ecsTypes.Tag <span class="cov0" title="0">{
        tags := []ecsTypes.Tag{
                {
                        Key:   awsStd.String(constants.TaskDefinitionDockerImageTagKey),
                        Value: awsStd.String(image),
                },
                {
                        Key:   awsStd.String("Application"),
                        Value: awsStd.String("runvoy"),
                },
        }
        if isDefault != nil &amp;&amp; *isDefault </span><span class="cov0" title="0">{
                tags = append(tags, ecsTypes.Tag{
                        Key:   awsStd.String(constants.TaskDefinitionIsDefaultTagKey),
                        Value: awsStd.String(constants.TaskDefinitionIsDefaultTagValue),
                })
        }</span>
        <span class="cov0" title="0">return tags</span>
}

// buildTaskDefinitionInput creates the RegisterTaskDefinitionInput for a new task definition.
//
//nolint:funlen // Large data structure definition
func buildTaskDefinitionInput(
        family, image, taskExecRoleARN, taskRoleARN, region string, cfg *Config,
) *ecs.RegisterTaskDefinitionInput <span class="cov0" title="0">{
        registerInput := &amp;ecs.RegisterTaskDefinitionInput{
                Family:      awsStd.String(family),
                NetworkMode: ecsTypes.NetworkModeAwsvpc,
                RequiresCompatibilities: []ecsTypes.Compatibility{
                        ecsTypes.CompatibilityFargate,
                },
                Cpu:              awsStd.String("256"),
                Memory:           awsStd.String("512"),
                ExecutionRoleArn: awsStd.String(taskExecRoleARN),
                EphemeralStorage: &amp;ecsTypes.EphemeralStorage{
                        SizeInGiB: constants.ECSEphemeralStorageSizeGiB,
                },
                Volumes: []ecsTypes.Volume{
                        {
                                Name: awsStd.String(constants.SharedVolumeName),
                        },
                },
                ContainerDefinitions: []ecsTypes.ContainerDefinition{
                        {
                                Name:      awsStd.String(constants.SidecarContainerName),
                                Image:     awsStd.String("public.ecr.aws/docker/library/alpine:latest"),
                                Essential: awsStd.Bool(false),
                                Command: []string{
                                        "/bin/sh",
                                        "-c",
                                        "echo \"This task definition is a template. Command will be overridden at runtime.\"",
                                },
                                MountPoints: []ecsTypes.MountPoint{
                                        {
                                                ContainerPath: awsStd.String(constants.SharedVolumePath),
                                                SourceVolume:  awsStd.String(constants.SharedVolumeName),
                                        },
                                },
                                LogConfiguration: &amp;ecsTypes.LogConfiguration{
                                        LogDriver: ecsTypes.LogDriverAwslogs,
                                        Options: map[string]string{
                                                "awslogs-group":         cfg.LogGroup,
                                                "awslogs-region":        region,
                                                "awslogs-stream-prefix": "sidecar",
                                        },
                                },
                        },
                        {
                                Name:      awsStd.String(constants.RunnerContainerName),
                                Image:     awsStd.String(image),
                                Essential: awsStd.Bool(true),
                                DependsOn: []ecsTypes.ContainerDependency{
                                        {
                                                ContainerName: awsStd.String(constants.SidecarContainerName),
                                                Condition:     ecsTypes.ContainerConditionSuccess,
                                        },
                                },
                                Command: []string{
                                        "/bin/sh",
                                        "-c",
                                        "echo \"This task definition is a template. Command will be overridden at runtime.\"",
                                },
                                WorkingDirectory: awsStd.String("/workspace/repo"),
                                MountPoints: []ecsTypes.MountPoint{
                                        {
                                                ContainerPath: awsStd.String(constants.SharedVolumePath),
                                                SourceVolume:  awsStd.String(constants.SharedVolumeName),
                                        },
                                },
                                LogConfiguration: &amp;ecsTypes.LogConfiguration{
                                        LogDriver: ecsTypes.LogDriverAwslogs,
                                        Options: map[string]string{
                                                "awslogs-group":         cfg.LogGroup,
                                                "awslogs-region":        region,
                                                "awslogs-stream-prefix": "task",
                                        },
                                },
                        },
                },
        }
        if taskRoleARN != "" </span><span class="cov0" title="0">{
                registerInput.TaskRoleArn = awsStd.String(taskRoleARN)
        }</span>
        <span class="cov0" title="0">return registerInput</span>
}

// RegisterTaskDefinitionForImage registers a new ECS task definition for the given Docker image.
// The task definition uses the same structure as before (sidecar + runner), but with the specified runner image.
// The Docker image is stored in a task definition tag for reliable retrieval.
// If isDefault is true, the image will be tagged as the default image.
//
//nolint:funlen // Complex AWS API orchestration
func RegisterTaskDefinitionForImage(
        ctx context.Context,
        ecsClient *ecs.Client,
        cfg *Config,
        image string,
        isDefault *bool,
        region string,
        logger *slog.Logger,
) error <span class="cov0" title="0">{
        family := TaskDefinitionFamilyName(image)

        taskDefArns, err := listTaskDefinitionsByPrefix(ctx, ecsClient, family)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var existingTaskDefARN string
        if len(taskDefArns) &gt; 0 </span><span class="cov0" title="0">{
                existingTaskDefARN = taskDefArns[len(taskDefArns)-1]
                logger.Debug("task definition already exists", "context", map[string]string{
                        "family": family,
                        "arn":    existingTaskDefARN,
                })
        }</span>

        <span class="cov0" title="0">if tagErr := handleDefaultImageTagging(ctx, ecsClient, isDefault, existingTaskDefARN, logger); tagErr != nil </span><span class="cov0" title="0">{
                return tagErr
        }</span>

        <span class="cov0" title="0">if existingTaskDefARN != "" </span><span class="cov0" title="0">{
                return updateExistingTaskDefTags(ctx, ecsClient, existingTaskDefARN, image, isDefault, family, logger)
        }</span>

        <span class="cov0" title="0">taskExecRoleARN, taskRoleARN := getRoleARNsFromExistingTaskDef(
                ctx, ecsClient, cfg.TaskExecRoleARN, cfg.TaskRoleARN,
        )

        if taskExecRoleARN == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("task execution role ARN is required but not found in config or existing task definitions")
        }</span>

        <span class="cov0" title="0">registerInput := buildTaskDefinitionInput(family, image, taskExecRoleARN, taskRoleARN, region, cfg)
        registerOutput, err := ecsClient.RegisterTaskDefinition(ctx, registerInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register task definition: %w", err)
        }</span>

        <span class="cov0" title="0">taskDefARN := awsStd.ToString(registerOutput.TaskDefinition.TaskDefinitionArn)
        tags := buildTaskDefinitionTags(image, isDefault)

        if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                _, tagErr := ecsClient.TagResource(ctx, &amp;ecs.TagResourceInput{
                        ResourceArn: awsStd.String(taskDefARN),
                        Tags:        tags,
                })
                if tagErr != nil </span><span class="cov0" title="0">{
                        logger.Warn(
                                "failed to tag task definition (task definition registered successfully)",
                                "arn", taskDefARN,
                                "error", tagErr,
                        )
                }</span>
        }

        <span class="cov0" title="0">logger.Info("registered task definition", "family", family, "arn", taskDefARN, "image", image)
        return nil</span>
}

// checkIfImageIsDefault checks if the image being removed is marked as default.
func checkIfImageIsDefault(ctx context.Context, ecsClient *ecs.Client, family string, logger *slog.Logger) bool <span class="cov0" title="0">{
        taskDefArns, err := listTaskDefinitionsByPrefix(ctx, ecsClient, family)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to check if image is default before removal", "error", err)
                return false
        }</span>

        <span class="cov0" title="0">for _, taskDefARN := range taskDefArns </span><span class="cov0" title="0">{
                tagsOutput, listErr := ecsClient.ListTagsForResource(ctx, &amp;ecs.ListTagsForResourceInput{
                        ResourceArn: awsStd.String(taskDefARN),
                })
                if listErr == nil &amp;&amp; tagsOutput != nil </span><span class="cov0" title="0">{
                        for _, tag := range tagsOutput.Tags </span><span class="cov0" title="0">{
                                if tag.Key != nil &amp;&amp; *tag.Key == constants.TaskDefinitionIsDefaultTagKey &amp;&amp;
                                        tag.Value != nil &amp;&amp; *tag.Value == constants.TaskDefinitionIsDefaultTagValue </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}

// deregisterAllTaskDefRevisions deregisters all active task definition revisions for a given family.
func deregisterAllTaskDefRevisions(
        ctx context.Context, ecsClient *ecs.Client, family, image string, logger *slog.Logger,
) error <span class="cov0" title="0">{
        nextToken := ""
        logger.Debug("calling external service", "context", map[string]string{
                "operation": "ECS.ListTaskDefinitions",
                "family":    family,
                "image":     image,
                "status":    string(ecsTypes.TaskDefinitionStatusActive),
                "paginated": "true",
        })

        for </span><span class="cov0" title="0">{
                listOutput, err := ecsClient.ListTaskDefinitions(ctx, &amp;ecs.ListTaskDefinitionsInput{
                        FamilyPrefix: awsStd.String(family),
                        Status:       ecsTypes.TaskDefinitionStatusActive,
                        MaxResults:   awsStd.Int32(constants.ECSTaskDefinitionMaxResults),
                        NextToken:    awsStd.String(nextToken),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list task definitions: %w", err)
                }</span>

                <span class="cov0" title="0">for _, taskDefARN := range listOutput.TaskDefinitionArns </span><span class="cov0" title="0">{
                        _, deregErr := ecsClient.DeregisterTaskDefinition(ctx, &amp;ecs.DeregisterTaskDefinitionInput{
                                TaskDefinition: awsStd.String(taskDefARN),
                        })
                        if deregErr != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to deregister task definition revision", "context", map[string]string{
                                        "family": family,
                                        "image":  image,
                                        "arn":    taskDefARN,
                                        "error":  deregErr.Error(),
                                })
                                return fmt.Errorf("failed to deregister task definition revision: %w", deregErr)
                        }</span>

                        <span class="cov0" title="0">logger.Info("deregistered task definition revision", "context", map[string]string{
                                "family": family,
                                "image":  image,
                                "arn":    taskDefARN,
                        })</span>
                }

                <span class="cov0" title="0">if listOutput.NextToken == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">nextToken = *listOutput.NextToken</span>
        }

        <span class="cov0" title="0">logger.Info("deregistered all task definition revisions", "context", map[string]string{
                "family": family,
                "image":  image,
        })
        return nil</span>
}

// markLastRemainingImageAsDefault marks the last remaining image as default if needed.
//
//nolint:funlen // Complex AWS API orchestration
func markLastRemainingImageAsDefault(
        ctx context.Context, ecsClient *ecs.Client, family string, logger *slog.Logger,
) error <span class="cov0" title="0">{
        familyPrefix := constants.TaskDefinitionFamilyPrefix + "-"
        remainingTaskDefs, err := listTaskDefinitionsByPrefix(ctx, ecsClient, familyPrefix)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to list remaining task definitions after removal", "error", err)
                return nil
        }</span>

        <span class="cov0" title="0">remainingImages := make(map[string]string)
        for _, taskDefARN := range remainingTaskDefs </span><span class="cov0" title="0">{
                descOutput, descErr := ecsClient.DescribeTaskDefinition(ctx, &amp;ecs.DescribeTaskDefinitionInput{
                        TaskDefinition: awsStd.String(taskDefARN),
                })
                if descErr != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to describe task definition", "context", map[string]string{
                                "family": family,
                                "arn":    taskDefARN,
                                "error":  descErr.Error(),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">if descOutput.TaskDefinition == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for i := range descOutput.TaskDefinition.ContainerDefinitions </span><span class="cov0" title="0">{
                        container := &amp;descOutput.TaskDefinition.ContainerDefinitions[i]
                        if container.Name != nil &amp;&amp; *container.Name == constants.RunnerContainerName &amp;&amp; container.Image != nil </span><span class="cov0" title="0">{
                                remainingImages[*container.Image] = taskDefARN
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if len(remainingImages) == 1 </span><span class="cov0" title="0">{
                var lastImage string
                var lastTaskDefARN string
                for img, arn := range remainingImages </span><span class="cov0" title="0">{
                        lastImage = img
                        lastTaskDefARN = arn
                }</span>

                <span class="cov0" title="0">logger.Info("only one image remaining after removing default, marking it as default",
                        "image", lastImage)

                tags := []ecsTypes.Tag{
                        {
                                Key:   awsStd.String(constants.TaskDefinitionIsDefaultTagKey),
                                Value: awsStd.String(constants.TaskDefinitionIsDefaultTagValue),
                        },
                        {
                                Key:   awsStd.String(constants.TaskDefinitionDockerImageTagKey),
                                Value: awsStd.String(lastImage),
                        },
                }

                _, tagErr := ecsClient.TagResource(ctx, &amp;ecs.TagResourceInput{
                        ResourceArn: awsStd.String(lastTaskDefARN),
                        Tags:        tags,
                })
                if tagErr != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to tag last remaining image as default", "context", map[string]string{
                                "image": lastImage,
                                "arn":   lastTaskDefARN,
                                "error": tagErr.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("marked last remaining image as default", "context", map[string]string{
                                "image": lastImage,
                                "arn":   lastTaskDefARN,
                        })
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// DeregisterTaskDefinitionsForImage deregisters all task definition revisions for a given image.
// If the removed image was the default and only one image remains, that image becomes the new default.
func DeregisterTaskDefinitionsForImage(
        ctx context.Context,
        ecsClient *ecs.Client,
        image string,
        logger *slog.Logger,
) error <span class="cov0" title="0">{
        family := TaskDefinitionFamilyName(image)

        wasDefault := checkIfImageIsDefault(ctx, ecsClient, family, logger)

        if err := deregisterAllTaskDefRevisions(ctx, ecsClient, family, image, logger); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if wasDefault </span><span class="cov0" title="0">{
                if err := markLastRemainingImageAsDefault(ctx, ecsClient, family, logger); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package app provides the core application logic for runvoy.
// It initializes and manages the service layer.
package app

import (
        "context"
        "fmt"
        "log/slog"

        appAws "runvoy/internal/app/aws"
        "runvoy/internal/config"
        "runvoy/internal/constants"
        "runvoy/internal/database"
        dynamoRepo "runvoy/internal/database/dynamodb"

        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/ecs"
)

// Initialize creates a new Service configured for the specified backend provider.
// It returns an error if the context is canceled, timed out, or if an unknown provider is specified.
// Callers should handle errors and potentially panic if initialization fails during startup.
//
// Supported cloud providers:
//   - "aws": Uses DynamoDB for storage, Fargate for execution
//   - "gcp": (future) E.g. using Google Cloud Run and Firestore for storage
func Initialize(
        ctx context.Context,
        provider constants.BackendProvider,
        cfg *config.Config,
        logger *slog.Logger) (*Service, error) <span class="cov0" title="0">{
        logger.Debug(fmt.Sprintf("initializing %s service", constants.ProjectName),
                "provider", provider,
                "version", *constants.GetVersion(),
                "init_timeout_seconds", cfg.InitTimeout.Seconds(),
        )

        var (
                userRepo      database.UserRepository
                executionRepo database.ExecutionRepository
                runner        Runner
                err           error
        )

        switch provider </span>{
        case constants.AWS:<span class="cov0" title="0">
                userRepo, executionRepo, runner, err = initializeAWSBackend(ctx, cfg, logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to initialize AWS: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown backend provider: %s (supported: %s)", provider, constants.AWS)</span>
        }

        <span class="cov0" title="0">logger.Debug(constants.ProjectName + " orchestrator initialized successfully")

        return NewService(userRepo, executionRepo, runner, logger, provider), nil</span>
}

// initializeAWSBackend sets up AWS-specific dependencies
func initializeAWSBackend(
        ctx context.Context,
        cfg *config.Config,
        logger *slog.Logger) (database.UserRepository, database.ExecutionRepository, Runner, error) <span class="cov0" title="0">{
        if cfg.APIKeysTable == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("APIKeysTable cannot be empty")
        }</span>

        <span class="cov0" title="0">if cfg.ExecutionsTable == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("ExecutionsTable cannot be empty")
        }</span>

        <span class="cov0" title="0">if cfg.PendingAPIKeysTable == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("PendingAPIKeysTable cannot be empty")
        }</span>

        <span class="cov0" title="0">if cfg.ECSCluster == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("ECSCluster cannot be empty")
        }</span>

        <span class="cov0" title="0">awsCfg, err := awsConfig.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("failed to load AWS configuration: %w", err)
        }</span>

        <span class="cov0" title="0">dynamoClient := dynamodb.NewFromConfig(awsCfg)
        ecsClientInstance := ecs.NewFromConfig(awsCfg)

        logger.Debug("DynamoDB backend configured", "context", map[string]string{
                "apiKeysTable":        cfg.APIKeysTable,
                "executionsTable":     cfg.ExecutionsTable,
                "pendingAPIKeysTable": cfg.PendingAPIKeysTable,
        })

        userRepo := dynamoRepo.NewUserRepository(dynamoClient, cfg.APIKeysTable, cfg.PendingAPIKeysTable, logger)
        executionRepo := dynamoRepo.NewExecutionRepository(dynamoClient, cfg.ExecutionsTable, logger)

        awsExecCfg := &amp;appAws.Config{
                ECSCluster:      cfg.ECSCluster,
                Subnet1:         cfg.Subnet1,
                Subnet2:         cfg.Subnet2,
                SecurityGroup:   cfg.SecurityGroup,
                LogGroup:        cfg.LogGroup,
                TaskExecRoleARN: cfg.TaskExecRoleARN,
                TaskRoleARN:     cfg.TaskRoleARN,
                Region:          awsCfg.Region,
        }
        runner := appAws.NewRunner(ecsClientInstance, awsExecCfg, logger)

        return userRepo, executionRepo, runner, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package app

import (
        "context"
        "fmt"
        "log/slog"
        "net/mail"
        "slices"
        "strings"
        "time"

        "runvoy/internal/api"
        "runvoy/internal/auth"
        "runvoy/internal/constants"
        "runvoy/internal/database"
        apperrors "runvoy/internal/errors"
        "runvoy/internal/logger"
)

// Runner abstracts provider-specific command execution (e.g., AWS ECS, GCP, etc.).
type Runner interface {
        // StartTask triggers an execution on the underlying platform and returns
        // a stable executionID and the task creation timestamp.
        // The createdAt timestamp comes from the provider (e.g., ECS CreatedAt) when available.
        StartTask(
                ctx context.Context,
                userEmail string,
                req *api.ExecutionRequest) (executionID string, createdAt *time.Time, err error)
        // KillTask terminates a running task identified by executionID.
        // Returns an error if the task is already terminated or cannot be terminated.
        KillTask(ctx context.Context, executionID string) error
        // RegisterImage registers a Docker image as a task definition in the execution platform.
        // isDefault: if true, explicitly set as default.
        // If nil or false, becomes default only if no default exists (first image behavior).
        RegisterImage(ctx context.Context, image string, isDefault *bool) error
        // ListImages lists all registered Docker images.
        ListImages(ctx context.Context) ([]api.ImageInfo, error)
        // RemoveImage removes a Docker image and deregisters its task definitions.
        RemoveImage(ctx context.Context, image string) error
        // FetchLogsByExecutionID retrieves logs for a specific execution.
        // Returns empty slice if logs are not available or not supported by the provider.
        FetchLogsByExecutionID(ctx context.Context, executionID string) ([]api.LogEvent, error)
}

// Service provides the core business logic for command execution and user management.
type Service struct {
        userRepo      database.UserRepository
        executionRepo database.ExecutionRepository
        runner        Runner
        Logger        *slog.Logger
        Provider      constants.BackendProvider
}

// NOTE: provider-specific configuration has been moved to subpackages (e.g., app/aws).

// NewService creates a new service instance.
// If userRepo is nil, user-related operations will not be available.
// This allows the service to work without database dependencies for simple operations.
func NewService(
        userRepo database.UserRepository,
        executionRepo database.ExecutionRepository,
        runner Runner,
        log *slog.Logger,
        provider constants.BackendProvider) *Service <span class="cov8" title="1">{
        return &amp;Service{
                userRepo:      userRepo,
                executionRepo: executionRepo,
                runner:        runner,
                Logger:        log,
                Provider:      provider,
        }
}</span>

// validateCreateUserRequest validates the email in the create user request.
func (s *Service) validateCreateUserRequest(ctx context.Context, email string) error <span class="cov0" title="0">{
        if email == "" </span><span class="cov0" title="0">{
                return apperrors.ErrBadRequest("email is required", nil)
        }</span>

        <span class="cov0" title="0">if _, err := mail.ParseAddress(email); err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrBadRequest("invalid email address", err)
        }</span>

        <span class="cov0" title="0">existingUser, err := s.userRepo.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if existingUser != nil </span><span class="cov0" title="0">{
                return apperrors.ErrConflict("user with this email already exists", nil)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateOrUseAPIKey generates a new API key if none is provided.
func generateOrUseAPIKey(providedKey string) (string, error) <span class="cov0" title="0">{
        if providedKey != "" </span><span class="cov0" title="0">{
                return providedKey, nil
        }</span>
        <span class="cov0" title="0">apiKey, err := auth.GenerateAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrInternalError("failed to generate API key", err)
        }</span>
        <span class="cov0" title="0">return apiKey, nil</span>
}

// createPendingClaim creates a pending API key claim record.
func (s *Service) createPendingClaim(
        ctx context.Context, apiKey, email, createdByEmail string, expiresAt int64,
) (string, error) <span class="cov0" title="0">{
        secretToken, err := auth.GenerateSecretToken()
        if err != nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrInternalError("failed to generate secret token", err)
        }</span>

        <span class="cov0" title="0">pending := &amp;api.PendingAPIKey{
                SecretToken: secretToken,
                APIKey:      apiKey,
                UserEmail:   email,
                CreatedBy:   createdByEmail,
                CreatedAt:   time.Now().UTC(),
                ExpiresAt:   expiresAt,
                Viewed:      false,
        }

        if err = s.userRepo.CreatePendingAPIKey(ctx, pending); err != nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrDatabaseError("failed to create pending API key", err)
        }</span>

        <span class="cov0" title="0">return secretToken, nil</span>
}

// CreateUser creates a new user with an API key and returns a claim token.
// If no API key is provided in the request, one will be generated.
func (s *Service) CreateUser(
        ctx context.Context, req api.CreateUserRequest, createdByEmail string,
) (*api.CreateUserResponse, error) <span class="cov0" title="0">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("user repository not configured", nil)
        }</span>

        <span class="cov0" title="0">if err := s.validateCreateUserRequest(ctx, req.Email); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">apiKey, err := generateOrUseAPIKey(req.APIKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">apiKeyHash := auth.HashAPIKey(apiKey)

        user := &amp;api.User{
                Email:     req.Email,
                CreatedAt: time.Now().UTC(),
                Revoked:   false,
        }

        expiresAt := time.Now().Add(constants.ClaimURLExpirationMinutes * time.Minute).Unix()

        if err = s.userRepo.CreateUserWithExpiration(ctx, user, apiKeyHash, expiresAt); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to create user", err)
        }</span>

        <span class="cov0" title="0">secretToken, err := s.createPendingClaim(ctx, apiKey, req.Email, createdByEmail, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                _ = s.userRepo.RevokeUser(ctx, req.Email)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;api.CreateUserResponse{
                User:       user,
                ClaimToken: secretToken,
        }, nil</span>
}

// ClaimAPIKey retrieves and claims a pending API key by its secret token.
func (s *Service) ClaimAPIKey(
        ctx context.Context,
        secretToken string,
        ipAddress string,
) (*api.ClaimAPIKeyResponse, error) <span class="cov0" title="0">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("user repository not configured", nil)
        }</span>

        // Retrieve pending key
        <span class="cov0" title="0">pending, err := s.userRepo.GetPendingAPIKey(ctx, secretToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to retrieve pending key", err)
        }</span>

        <span class="cov0" title="0">if pending == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrNotFound("invalid or expired token", nil)
        }</span>

        // Check if already viewed
        <span class="cov0" title="0">if pending.Viewed </span><span class="cov0" title="0">{
                return nil, apperrors.ErrConflict("key has already been claimed", nil)
        }</span>

        // Check if expired
        <span class="cov0" title="0">now := time.Now().Unix()
        if pending.ExpiresAt &lt; now </span><span class="cov0" title="0">{
                return nil, apperrors.ErrNotFound("token has expired", nil)
        }</span>

        // Mark as viewed atomically
        <span class="cov0" title="0">if markErr := s.userRepo.MarkAsViewed(ctx, secretToken, ipAddress); markErr != nil </span><span class="cov0" title="0">{
                return nil, markErr
        }</span>

        // Remove expiration from user record (make user permanent)
        <span class="cov0" title="0">if removeErr := s.userRepo.RemoveExpiration(ctx, pending.UserEmail); removeErr != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the claim - user already exists and can authenticate
                s.Logger.Error("failed to remove expiration from user record", "error", removeErr, "email", pending.UserEmail)
        }</span>

        <span class="cov0" title="0">return &amp;api.ClaimAPIKeyResponse{
                APIKey:    pending.APIKey,
                UserEmail: pending.UserEmail,
                Message:   "API key claimed successfully",
        }, nil</span>
}

// AuthenticateUser verifies an API key and returns the associated user.
// Returns appropriate errors for invalid API keys, revoked keys, or server errors.
func (s *Service) AuthenticateUser(ctx context.Context, apiKey string) (*api.User, error) <span class="cov8" title="1">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("user repository not configured", nil)
        }</span>

        <span class="cov8" title="1">if apiKey == "" </span><span class="cov8" title="1">{
                return nil, apperrors.ErrBadRequest("API key is required", nil)
        }</span>

        <span class="cov8" title="1">apiKeyHash := auth.HashAPIKey(apiKey)

        user, err := s.userRepo.GetUserByAPIKeyHash(ctx, apiKeyHash)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if user == nil </span><span class="cov8" title="1">{
                return nil, apperrors.ErrInvalidAPIKey(nil)
        }</span>

        <span class="cov8" title="1">if user.Revoked </span><span class="cov8" title="1">{
                return nil, apperrors.ErrAPIKeyRevoked(nil)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// UpdateUserLastUsed updates the user's last_used timestamp after successful authentication.
// This is a best-effort operation; callers may choose to log failures without failing the request.
func (s *Service) UpdateUserLastUsed(ctx context.Context, email string) (*time.Time, error) <span class="cov8" title="1">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("user repository not configured", nil)
        }</span>
        <span class="cov8" title="1">if email == "" </span><span class="cov8" title="1">{
                return nil, apperrors.ErrBadRequest("email is required", nil)
        }</span>
        <span class="cov8" title="1">return s.userRepo.UpdateLastUsed(ctx, email)</span>
}

// RevokeUser marks a user's API key as revoked.
// Returns an error if the user does not exist or revocation fails.
func (s *Service) RevokeUser(ctx context.Context, email string) error <span class="cov8" title="1">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return apperrors.ErrInternalError("user repository not configured", nil)
        }</span>

        <span class="cov8" title="1">if email == "" </span><span class="cov8" title="1">{
                return apperrors.ErrBadRequest("email is required", nil)
        }</span>

        <span class="cov8" title="1">user, err := s.userRepo.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov8" title="1">{
                // Propagate database errors as-is
                return err
        }</span>
        <span class="cov8" title="1">if user == nil </span><span class="cov8" title="1">{
                return apperrors.ErrNotFound("user not found", nil)
        }</span>

        <span class="cov8" title="1">if revokeErr := s.userRepo.RevokeUser(ctx, email); revokeErr != nil </span><span class="cov8" title="1">{
                // Propagate errors as-is (they already have proper status codes)
                return revokeErr
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListUsers returns all users in the system (excluding API key hashes for security).
// Returns an error if the user repository is not configured or if the query fails.
// Sort by email ascending.
func (s *Service) ListUsers(ctx context.Context) (*api.ListUsersResponse, error) <span class="cov0" title="0">{
        if s.userRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("user repository not configured", nil)
        }</span>

        <span class="cov0" title="0">users, err := s.userRepo.ListUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">slices.SortFunc(users, func(a, b *api.User) int </span><span class="cov0" title="0">{
                return strings.Compare(a.Email, b.Email)
        }</span>)

        <span class="cov0" title="0">return &amp;api.ListUsersResponse{
                Users: users,
        }, nil</span>
}

// RunCommand starts a provider-specific task and records the execution.
func (s *Service) RunCommand(
        ctx context.Context,
        userEmail string,
        req *api.ExecutionRequest) (*api.ExecutionResponse, error) <span class="cov8" title="1">{
        if s.executionRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("execution repository not configured", nil)
        }</span>

        <span class="cov8" title="1">if req.Command == "" </span><span class="cov8" title="1">{
                return nil, apperrors.ErrBadRequest("command is required", nil)
        }</span>
        <span class="cov8" title="1">executionID, createdAt, err := s.runner.StartTask(ctx, userEmail, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">reqLogger := logger.DeriveRequestLogger(ctx, s.Logger)
        startedAt := time.Now().UTC()
        if createdAt != nil </span><span class="cov8" title="1">{
                startedAt = createdAt.UTC()
        }</span>

        <span class="cov8" title="1">reqLogger.Info("task started", "task", map[string]string{
                "executionID": executionID,
                "startedAt":   startedAt.Format(time.RFC3339),
        })

        requestID := logger.GetRequestID(ctx)
        execution := &amp;api.Execution{
                ExecutionID:     executionID,
                UserEmail:       userEmail,
                Command:         req.Command,
                LockName:        req.Lock,
                StartedAt:       startedAt,
                Status:          string(constants.ExecutionRunning),
                RequestID:       requestID,
                ComputePlatform: string(s.Provider),
        }

        if requestID == "" </span><span class="cov8" title="1">{
                reqLogger.Warn("request ID not available; storing execution without request ID",
                        "executionID", executionID,
                )
        }</span>

        <span class="cov8" title="1">if err = s.executionRepo.CreateExecution(ctx, execution); err != nil </span><span class="cov8" title="1">{
                reqLogger.Error("failed to create execution record, but task started",
                        "error", err,
                        "executionID", executionID,
                )
                // Continue even if recording fails - the task is already running
        }</span>

        <span class="cov8" title="1">return &amp;api.ExecutionResponse{
                ExecutionID: executionID,
                Status:      string(constants.ExecutionRunning),
        }, nil</span>
}

// GetLogsByExecutionID returns aggregated Cloud logs for a given execution
func (s *Service) GetLogsByExecutionID(ctx context.Context, executionID string) (*api.LogsResponse, error) <span class="cov8" title="1">{
        if executionID == "" </span><span class="cov8" title="1">{
                return nil, apperrors.ErrBadRequest("executionID is required", nil)
        }</span>

        <span class="cov8" title="1">events, err := s.runner.FetchLogsByExecutionID(ctx, executionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;api.LogsResponse{ExecutionID: executionID, Events: events}, nil</span>
}

// GetExecutionStatus returns the current status and metadata for a given execution ID
func (s *Service) GetExecutionStatus(ctx context.Context, executionID string) (*api.ExecutionStatusResponse, error) <span class="cov8" title="1">{
        if s.executionRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("execution repository not configured", nil)
        }</span>
        <span class="cov8" title="1">if executionID == "" </span><span class="cov8" title="1">{
                return nil, apperrors.ErrBadRequest("executionID is required", nil)
        }</span>

        <span class="cov8" title="1">execution, err := s.executionRepo.GetExecution(ctx, executionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if execution == nil </span><span class="cov8" title="1">{
                return nil, apperrors.ErrNotFound("execution not found", nil)
        }</span>

        <span class="cov8" title="1">var exitCodePtr *int
        if execution.CompletedAt != nil </span><span class="cov8" title="1">{
                // Only populate ExitCode if we have actually recorded completion
                ec := execution.ExitCode
                exitCodePtr = &amp;ec
        }</span>

        <span class="cov8" title="1">return &amp;api.ExecutionStatusResponse{
                ExecutionID: execution.ExecutionID,
                Status:      execution.Status,
                ExitCode:    exitCodePtr,
                StartedAt:   execution.StartedAt,
                CompletedAt: execution.CompletedAt,
        }, nil</span>
}

// KillExecution terminates a running execution identified by executionID.
// It verifies the execution exists in the database and checks task status before termination.
// Returns an error if the execution is not found, already terminated, or termination fails.
func (s *Service) KillExecution(ctx context.Context, executionID string) error <span class="cov8" title="1">{
        if s.executionRepo == nil </span><span class="cov0" title="0">{
                return apperrors.ErrInternalError("execution repository not configured", nil)
        }</span>
        <span class="cov8" title="1">if executionID == "" </span><span class="cov8" title="1">{
                return apperrors.ErrBadRequest("executionID is required", nil)
        }</span>

        <span class="cov8" title="1">reqLogger := logger.DeriveRequestLogger(ctx, s.Logger)

        // First, verify the execution exists in the database
        execution, err := s.executionRepo.GetExecution(ctx, executionID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if execution == nil </span><span class="cov8" title="1">{
                return apperrors.ErrNotFound("execution not found", nil)
        }</span>

        <span class="cov8" title="1">reqLogger.Debug("execution found", "executionID", executionID, "status", execution.Status)

        // Check if execution is already in a terminal state
        terminalStatuses := constants.TerminalExecutionStatuses()
        if slices.ContainsFunc(terminalStatuses, func(status constants.ExecutionStatus) bool </span><span class="cov8" title="1">{
                return execution.Status == string(status)
        }</span>) <span class="cov8" title="1">{
                return apperrors.ErrBadRequest(
                        "execution is already terminated",
                        fmt.Errorf("execution status: %s", execution.Status))
        }</span>

        // Delegate to the runner to kill the task
        <span class="cov8" title="1">if killErr := s.runner.KillTask(ctx, executionID); killErr != nil </span><span class="cov8" title="1">{
                return killErr
        }</span>

        <span class="cov8" title="1">reqLogger.Info("execution termination initiated", "executionID", executionID)

        return nil</span>
}

// ListExecutions returns all executions currently present in the database.
// Fields with no values are omitted in JSON due to omitempty tags on api.Execution.
func (s *Service) ListExecutions(ctx context.Context) ([]*api.Execution, error) <span class="cov8" title="1">{
        if s.executionRepo == nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("execution repository not configured", nil)
        }</span>
        <span class="cov8" title="1">executions, err := s.executionRepo.ListExecutions(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return executions, nil</span>
}

// RegisterImage registers a Docker image and creates the corresponding task definition.
func (s *Service) RegisterImage(
        ctx context.Context,
        image string,
        isDefault *bool,
) (*api.RegisterImageResponse, error) <span class="cov8" title="1">{
        if image == "" </span><span class="cov8" title="1">{
                return nil, apperrors.ErrBadRequest("image is required", nil)
        }</span>

        <span class="cov8" title="1">if err := s.runner.RegisterImage(ctx, image, isDefault); err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.ErrInternalError("failed to register image", err)
        }</span>

        <span class="cov8" title="1">return &amp;api.RegisterImageResponse{
                Image:   image,
                Message: "Image registered successfully",
        }, nil</span>
}

// ListImages returns all registered Docker images.
func (s *Service) ListImages(ctx context.Context) (*api.ListImagesResponse, error) <span class="cov8" title="1">{
        images, err := s.runner.ListImages(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.ErrInternalError("failed to list images", err)
        }</span>

        <span class="cov8" title="1">return &amp;api.ListImagesResponse{
                Images: images,
        }, nil</span>
}

// RemoveImage removes a Docker image and deregisters its task definitions.
func (s *Service) RemoveImage(ctx context.Context, image string) error <span class="cov8" title="1">{
        if image == "" </span><span class="cov8" title="1">{
                return apperrors.ErrBadRequest("image is required", nil)
        }</span>

        <span class="cov8" title="1">if err := s.runner.RemoveImage(ctx, image); err != nil </span><span class="cov8" title="1">{
                return apperrors.ErrInternalError("failed to remove image", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package auth provides authentication utilities for runvoy.
package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"

        "runvoy/internal/constants"
)

// GenerateAPIKey creates a cryptographically secure random API key.
// The key is base64-encoded and approximately 32 characters long.
func GenerateAPIKey() (string, error) <span class="cov8" title="1">{
        b := make([]byte, constants.APIKeyByteSize)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(b), nil</span>
}

// HashAPIKey creates a SHA-256 hash of the API key for secure storage.
// NOTICE: we never store plain API keys in the database.
func HashAPIKey(apiKey string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(apiKey))

        return base64.StdEncoding.EncodeToString(hash[:])
}</span>

// GenerateSecretToken creates a cryptographically secure random secret token for claim URLs.
// The token is base64-encoded and approximately 32 characters long.
func GenerateSecretToken() (string, error) <span class="cov0" title="0">{
        b := make([]byte, constants.SecretTokenByteSize)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(b), nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package client provides HTTP client functionality for the runvoy API.
// It handles authentication, request/response serialization, and error handling.
package client

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "net/url"

        "runvoy/internal/api"
        "runvoy/internal/config"
        "runvoy/internal/constants"
        "runvoy/internal/logger"
)

// Client provides a generic HTTP client for API operations
type Client struct {
        config *config.Config
        logger *slog.Logger
}

// New creates a new API client
func New(cfg *config.Config, log *slog.Logger) *Client <span class="cov8" title="1">{
        return &amp;Client{
                config: cfg,
                logger: log,
        }
}</span>

// Request represents an API request
type Request struct {
        Method string
        Path   string
        Body   interface{}
}

// Response represents an API response
type Response struct {
        StatusCode int
        Body       []byte
}

// Do makes an HTTP request to the API
func (c *Client) Do(ctx context.Context, req Request) (*Response, error) <span class="cov0" title="0">{
        var bodyReader io.Reader
        if req.Body != nil </span><span class="cov0" title="0">{
                jsonData, err := json.Marshal(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
                <span class="cov0" title="0">bodyReader = bytes.NewBuffer(jsonData)</span>
        }

        <span class="cov0" title="0">apiURL, err := url.JoinPath(c.config.APIEndpoint, req.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid API endpoint: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, req.Method, apiURL, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set(constants.ContentTypeHeader, "application/json")
        httpReq.Header.Set(constants.APIKeyHeader, c.config.APIKey)

        // Log before making HTTP request with deadline info
        logArgs := []any{
                "operation", "HTTP.Request",
                "method", req.Method,
                "url", apiURL,
        }
        if req.Body != nil </span><span class="cov0" title="0">{
                bodyBytes, _ := json.Marshal(req.Body)
                logArgs = append(logArgs, "hasBody", true, "bodySize", len(bodyBytes))
        }</span> else<span class="cov0" title="0"> {
                logArgs = append(logArgs, "hasBody", false)
        }</span>
        <span class="cov0" title="0">logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        c.logger.Debug("calling external service", logArgs...)

        httpClient := &amp;http.Client{}
        resp, err := httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        // Log response summary
        <span class="cov0" title="0">c.logger.Debug("received HTTP response",
                "status", resp.StatusCode,
                "bodySize", len(body),
                "method", req.Method,
                "url", apiURL)

        return &amp;Response{
                StatusCode: resp.StatusCode,
                Body:       body,
        }, nil</span>
}

// DoJSON makes a request and unmarshals the response into the provided interface
func (c *Client) DoJSON(ctx context.Context, req Request, result interface{}) error <span class="cov0" title="0">{
        resp, err := c.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= constants.HTTPStatusBadRequest </span><span class="cov0" title="0">{
                var errorResp api.ErrorResponse
                if err = json.Unmarshal(resp.Body, &amp;errorResp); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(resp.Body))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("[%d] %s: %s", resp.StatusCode, errorResp.Error, errorResp.Details)</span>
        }

        <span class="cov0" title="0">if err = json.Unmarshal(resp.Body, result); err != nil </span><span class="cov0" title="0">{
                c.logger.Debug("response body", "body", string(resp.Body))
                return fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateUser creates a new user using the API
func (c *Client) CreateUser(ctx context.Context, req api.CreateUserRequest) (*api.CreateUserResponse, error) <span class="cov0" title="0">{
        var resp api.CreateUserResponse
        err := c.DoJSON(ctx, Request{
                Method: "POST",
                Path:   "/api/v1/users/create",
                Body:   req,
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// RevokeUser revokes a user's API key
func (c *Client) RevokeUser(ctx context.Context, req api.RevokeUserRequest) (*api.RevokeUserResponse, error) <span class="cov0" title="0">{
        var resp api.RevokeUserResponse
        err := c.DoJSON(ctx, Request{
                Method: "POST",
                Path:   "/api/v1/users/revoke",
                Body:   req,
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ListUsers lists all users
func (c *Client) ListUsers(ctx context.Context) (*api.ListUsersResponse, error) <span class="cov0" title="0">{
        var resp api.ListUsersResponse
        err := c.DoJSON(ctx, Request{
                Method: "GET",
                Path:   "/api/v1/users/",
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetHealth checks the API health status
func (c *Client) GetHealth(ctx context.Context) (*api.HealthResponse, error) <span class="cov0" title="0">{
        var resp api.HealthResponse
        err := c.DoJSON(ctx, Request{
                Method: "GET",
                Path:   "/api/v1/health",
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// RunCommand executes a command remotely via the runvoy API.
func (c *Client) RunCommand(ctx context.Context, req *api.ExecutionRequest) (*api.ExecutionResponse, error) <span class="cov0" title="0">{
        var resp api.ExecutionResponse
        err := c.DoJSON(ctx, Request{
                Method: "POST",
                Path:   "/api/v1/run",
                Body:   req,
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetLogs gets the logs for an execution
func (c *Client) GetLogs(ctx context.Context, executionID string) (*api.LogsResponse, error) <span class="cov0" title="0">{
        var resp api.LogsResponse
        err := c.DoJSON(ctx, Request{
                Method: "GET",
                Path:   fmt.Sprintf("/api/v1/executions/%s/logs", executionID),
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetExecutionStatus gets the status of an execution
func (c *Client) GetExecutionStatus(ctx context.Context, executionID string) (*api.ExecutionStatusResponse, error) <span class="cov0" title="0">{
        var resp api.ExecutionStatusResponse
        err := c.DoJSON(ctx, Request{
                Method: "GET",
                Path:   fmt.Sprintf("/api/v1/executions/%s/status", executionID),
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// KillExecution stops a running execution by its ID
func (c *Client) KillExecution(ctx context.Context, executionID string) (*api.KillExecutionResponse, error) <span class="cov0" title="0">{
        var resp api.KillExecutionResponse
        err := c.DoJSON(ctx, Request{
                Method: "POST",
                Path:   fmt.Sprintf("/api/v1/executions/%s/kill", executionID),
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ListExecutions fetches all executions
func (c *Client) ListExecutions(ctx context.Context) ([]api.Execution, error) <span class="cov0" title="0">{
        var resp []api.Execution
        err := c.DoJSON(ctx, Request{
                Method: "GET",
                Path:   "/api/v1/executions",
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// ClaimAPIKey claims a user's API key
func (c *Client) ClaimAPIKey(ctx context.Context, token string) (*api.ClaimAPIKeyResponse, error) <span class="cov0" title="0">{
        var resp api.ClaimAPIKeyResponse
        err := c.DoJSON(ctx, Request{
                Method: "GET",
                Path:   fmt.Sprintf("/api/v1/claim/%s", token),
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// RegisterImage registers a new container image for execution, optionally marking it as the default
func (c *Client) RegisterImage(ctx context.Context, image string, isDefault *bool) (*api.RegisterImageResponse, error) <span class="cov0" title="0">{
        var resp api.RegisterImageResponse
        err := c.DoJSON(ctx, Request{
                Method: "POST",
                Path:   "/api/v1/images/register",
                Body:   api.RegisterImageRequest{Image: image, IsDefault: isDefault},
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ListImages retrieves all registered container images
func (c *Client) ListImages(ctx context.Context) (*api.ListImagesResponse, error) <span class="cov0" title="0">{
        var resp api.ListImagesResponse
        err := c.DoJSON(ctx, Request{
                Method: "GET",
                Path:   "/api/v1/images",
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UnregisterImage removes a container image from the registry
func (c *Client) UnregisterImage(ctx context.Context, image string) (*api.RemoveImageResponse, error) <span class="cov0" title="0">{
        var resp api.RemoveImageResponse
        err := c.DoJSON(ctx, Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/api/v1/images/%s", image),
        }, &amp;resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package config manages configuration for the runvoy CLI and services.
// It uses Viper for unified configuration management from files and environment variables.
package config

import (
        "fmt"
        "log/slog"
        "os"
        "os/user"
        "path/filepath"
        "strings"
        "time"

        "runvoy/internal/constants"

        "github.com/go-playground/validator/v10"
        "github.com/spf13/viper"
)

// Config represents the unified configuration structure for both CLI and services.
// It supports loading from YAML files and environment variables.
type Config struct {
        // CLI Configuration
        APIEndpoint  string `mapstructure:"api_endpoint" yaml:"api_endpoint" validate:"omitempty,url"`
        APIKey       string `mapstructure:"api_key" yaml:"api_key"`
        WebviewerURL string `mapstructure:"webviewer_url" yaml:"webviewer_url" validate:"omitempty,url"`

        // Orchestrator Service Configuration
        Port                string        `mapstructure:"port" validate:"omitempty"`
        RequestTimeout      time.Duration `mapstructure:"request_timeout"`
        APIKeysTable        string        `mapstructure:"api_keys_table"`
        ExecutionsTable     string        `mapstructure:"executions_table"`
        PendingAPIKeysTable string        `mapstructure:"pending_api_keys_table"`
        ECSCluster          string        `mapstructure:"ecs_cluster"`
        TaskDefinition      string        `mapstructure:"task_definition"`
        Subnet1             string        `mapstructure:"subnet_1"`
        Subnet2             string        `mapstructure:"subnet_2"`
        SecurityGroup       string        `mapstructure:"security_group"`
        LogGroup            string        `mapstructure:"log_group"`
        TaskExecRoleARN     string        `mapstructure:"task_exec_role_arn"`
        TaskRoleARN         string        `mapstructure:"task_role_arn"`
        InitTimeout         time.Duration `mapstructure:"init_timeout"`
        LogLevel            string        `mapstructure:"log_level"`
}

var validate = validator.New()

// Load loads the configuration using Viper.
// For CLI: loads from ~/.runvoy/config.yaml
// For services: loads from environment variables with RUNVOY_ prefix
// Environment variables take precedence over config file values.
func Load() (*Config, error) <span class="cov0" title="0">{
        v := viper.New()

        // Set defaults for service configuration
        setDefaults(v)

        // Try to load config file for CLI
        if err := loadConfigFile(v); err != nil </span><span class="cov0" title="0">{
                // Config file not found is acceptable for services (they use env vars only)
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error loading config file: %w", err)
                }</span>
        }

        // Bind environment variables
        <span class="cov0" title="0">v.SetEnvPrefix("RUNVOY")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()

        // Manually bind all env vars for better control
        bindEnvVars(v)

        var cfg Config
        var err error
        if err = v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling config: %w", err)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err = validate.Struct(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// LoadCLI loads configuration specifically for CLI usage.
// Returns an error if the config file doesn't exist.
func LoadCLI() (*Config, error) <span class="cov0" title="0">{
        v := viper.New()

        if err := loadConfigFile(v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// LoadOrchestrator loads configuration for the orchestrator service.
// Loads from environment variables and validates required fields.
// This maintains parity with the Lambda orchestrator which requires all AWS resources.
func LoadOrchestrator() (*Config, error) <span class="cov0" title="0">{
        v := viper.New()
        setDefaults(v)

        v.SetEnvPrefix("RUNVOY")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()
        bindEnvVars(v)

        var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling orchestrator config: %w", err)
        }</span>

        // Validate required fields (matches old caarlos0/env notEmpty tags)
        <span class="cov0" title="0">if err := validateOrchestrator(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// LoadEventProcessor loads configuration for the event processor service.
// Loads from environment variables and validates required fields.
func LoadEventProcessor() (*Config, error) <span class="cov0" title="0">{
        v := viper.New()
        setDefaults(v)

        v.SetEnvPrefix("RUNVOY")
        v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        v.AutomaticEnv()
        bindEnvVars(v)

        var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling event processor config: %w", err)
        }</span>

        // Validate required fields (matches old caarlos0/env notEmpty tags)
        <span class="cov0" title="0">if err := validateEventProcessor(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// MustLoadOrchestrator loads orchestrator configuration and exits on error.
// Suitable for application startup where configuration errors should be fatal.
func MustLoadOrchestrator() *Config <span class="cov0" title="0">{
        cfg, err := LoadOrchestrator()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to load orchestrator configuration", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}

// MustLoadEventProcessor loads event processor configuration and exits on error.
// Suitable for application startup where configuration errors should be fatal.
func MustLoadEventProcessor() *Config <span class="cov0" title="0">{
        cfg, err := LoadEventProcessor()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to load event processor configuration", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">return cfg</span>
}

// Save saves the configuration to the user's home directory.
// Overwrites the existing config file if it exists.
func Save(config *Config) error <span class="cov0" title="0">{
        currentUser, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting current user: %w", err)
        }</span>

        <span class="cov0" title="0">configDir := constants.ConfigDirPath(currentUser.HomeDir)

        if err = os.MkdirAll(configDir, constants.ConfigDirPermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating config directory: %w", err)
        }</span>

        <span class="cov0" title="0">configFilePath := filepath.Join(configDir, constants.ConfigFileName)

        v := viper.New()
        v.Set("api_endpoint", config.APIEndpoint)
        v.Set("api_key", config.APIKey)
        v.Set("webviewer_url", config.WebviewerURL)

        if err = v.WriteConfigAs(configFilePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error writing config file: %w", err)
        }</span>

        // Set proper permissions
        <span class="cov0" title="0">if err = os.Chmod(configFilePath, constants.ConfigFilePermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error setting config file permissions: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfigPath returns the path to the config file
func GetConfigPath() (string, error) <span class="cov8" title="1">{
        currentUser, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting current user: %w", err)
        }</span>

        <span class="cov8" title="1">configDir := constants.ConfigDirPath(currentUser.HomeDir)
        return filepath.Join(configDir, constants.ConfigFileName), nil</span>
}

// GetLogLevel returns the slog.Level from the string configuration.
// Defaults to INFO if the level string is invalid.
func (c *Config) GetLogLevel() slog.Level <span class="cov8" title="1">{
        var level slog.Level
        if err := level.UnmarshalText([]byte(c.LogLevel)); err != nil </span><span class="cov8" title="1">{
                return slog.LevelInfo
        }</span>
        <span class="cov8" title="1">return level</span>
}

// GetWebviewerURL returns the webviewer URL from configuration.
// Returns the configured URL if set, otherwise returns the default URL.
func (c *Config) GetWebviewerURL() string <span class="cov8" title="1">{
        if c.WebviewerURL != "" </span><span class="cov8" title="1">{
                return c.WebviewerURL
        }</span>
        <span class="cov8" title="1">return constants.DefaultWebviewerURL</span>
}

// Helper functions

func setDefaults(v *viper.Viper) <span class="cov0" title="0">{
        v.SetDefault("port", "56212")
        v.SetDefault("request_timeout", 0)
        v.SetDefault("init_timeout", "10s")
        v.SetDefault("log_level", "INFO")
        v.SetDefault("webviewer_url", constants.DefaultWebviewerURL)
}</span>

func loadConfigFile(v *viper.Viper) error <span class="cov0" title="0">{
        currentUser, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting current user: %w", err)
        }</span>

        <span class="cov0" title="0">configDir := constants.ConfigDirPath(currentUser.HomeDir)
        configFile := filepath.Join(configDir, constants.ConfigFileName)

        v.SetConfigFile(configFile)
        v.SetConfigType("yaml")

        if readErr := v.ReadInConfig(); readErr != nil </span><span class="cov0" title="0">{
                return readErr
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func bindEnvVars(v *viper.Viper) <span class="cov0" title="0">{
        // Bind all environment variables explicitly
        envVars := []string{
                "API_KEYS_TABLE",
                "DEV_SERVER_PORT",
                "ECS_CLUSTER",
                "EXECUTIONS_TABLE",
                "INIT_TIMEOUT",
                "LOG_GROUP",
                "LOG_LEVEL",
                "PENDING_API_KEYS_TABLE",
                "REQUEST_TIMEOUT",
                "SECURITY_GROUP",
                "SUBNET_1",
                "SUBNET_2",
                "TASK_DEFINITION",
                "TASK_EXEC_ROLE_ARN",
                "TASK_ROLE_ARN",
                "WEBVIEWER_URL",
        }

        for _, envVar := range envVars </span><span class="cov0" title="0">{
                // Map DEV_SERVER_PORT to port
                if envVar == "DEV_SERVER_PORT" </span><span class="cov0" title="0">{
                        _ = v.BindEnv("port", "RUNVOY_DEV_SERVER_PORT")
                }</span> else<span class="cov0" title="0"> {
                        // Convert to lowercase to match mapstructure tags (keep underscores)
                        configKey := strings.ToLower(envVar)
                        _ = v.BindEnv(configKey, "RUNVOY_"+envVar)
                }</span>
        }
}

// validateOrchestrator validates required fields for orchestrator service.
// These match the old caarlos0/env notEmpty tags to maintain parity.
// TaskDefinition is no longer required - task definitions are managed dynamically via API.
func validateOrchestrator(cfg *Config) error <span class="cov8" title="1">{
        required := map[string]string{
                "APIKeysTable":    cfg.APIKeysTable,
                "ExecutionsTable": cfg.ExecutionsTable,
                "ECSCluster":      cfg.ECSCluster,
                "Subnet1":         cfg.Subnet1,
                "Subnet2":         cfg.Subnet2,
                "SecurityGroup":   cfg.SecurityGroup,
                "LogGroup":        cfg.LogGroup,
        }

        for field, value := range required </span><span class="cov8" title="1">{
                if value == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s cannot be empty", field)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateEventProcessor validates required fields for event processor service.
// These match the old caarlos0/env notEmpty tags.
func validateEventProcessor(cfg *Config) error <span class="cov8" title="1">{
        required := map[string]string{
                "ExecutionsTable": cfg.ExecutionsTable,
                "ECSCluster":      cfg.ECSCluster,
        }

        for field, value := range required </span><span class="cov8" title="1">{
                if value == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s cannot be empty", field)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package constants defines global constants used throughout runvoy.
// It includes version information, paths, and configuration keys.
package constants

import "time"

var version = "0.0.0-development" // Updated by CI/CD pipeline at build time

// GetVersion returns the current version of runvoy.
func GetVersion() *string <span class="cov8" title="1">{
        return &amp;version
}</span>

// ProjectName is the name of the CLI tool and application
const ProjectName = "runvoy"

// ConfigDirName is the name of the configuration directory in the user's home directory
const ConfigDirName = ".runvoy"

// ConfigFileName is the name of the global configuration file
const ConfigFileName = "config.yaml"

// ConfigDirPath returns the full path to the global configuration directory.
func ConfigDirPath(homeDir string) string <span class="cov8" title="1">{
        return homeDir + "/" + ConfigDirName
}</span>

// ConfigFilePath returns the full path to the global configuration file
func ConfigFilePath(homeDir string) string <span class="cov8" title="1">{
        return ConfigDirPath(homeDir) + "/" + ConfigFileName
}</span>

// BackendProvider represents the backend infrastructure provider.
type BackendProvider string

const (
        // AWS is the Amazon Web Services backend provider.
        AWS BackendProvider = "AWS"
        // Example: GCP BackendProvider = "GCP"
)

// Environment represents the execution environment (e.g., CLI, Lambda).
type Environment string

// Environment types for logger configuration
const (
        Development Environment = "development"
        Production  Environment = "production"
        CLI         Environment = "cli"
)

// APIKeyHeader is the HTTP header name for API key authentication
//
//nolint:gosec // G101: This is a header name constant, not a hardcoded credential
const APIKeyHeader = "X-API-Key"

// ContentTypeHeader is the HTTP Content-Type header name.
const ContentTypeHeader = "Content-Type"

// ConfigCtxKeyType is the type for the config context key
type ConfigCtxKeyType string

// ConfigCtxKey is the key used to store config in context
const ConfigCtxKey ConfigCtxKeyType = "config"

// Service represents a runvoy service component.
type Service string

const (
        // OrchestratorService is the main orchestrator service.
        OrchestratorService Service = "orchestrator"
        // EventProcessorService is the event processing service.
        EventProcessorService Service = "event-processor"
)

// RunnerContainerName is the ECS container name used for task execution.
// Must match the container override name passed in the ECS RunTask call.
const RunnerContainerName = "runner"

// SidecarContainerName is the sidecar container name for auxiliary tasks.
// This container runs before the main runner container and handles tasks like
// .env file generation from user environment variables, git repository cloning, etc.
const SidecarContainerName = "sidecar"

// SharedVolumeName is the name of the shared volume between containers.
// Used for sharing the cloned git repository from sidecar to main container.
const SharedVolumeName = "workspace"

// SharedVolumePath is the mount path for the shared volume in both containers.
// When git repository is specified, the sidecar clones to /workspace/repo.
// The sidecar also creates .env file from user environment variables (prefixed with RUNVOY_USER_).
const SharedVolumePath = "/workspace"

// EcsStatus represents the AWS ECS Task LastStatus lifecycle values.
// These are string statuses returned by ECS DescribeTasks for Task.LastStatus.
type EcsStatus string

const (
        // EcsStatusProvisioning represents a task being provisioned
        EcsStatusProvisioning EcsStatus = "PROVISIONING"
        // EcsStatusPending represents a task pending activation
        EcsStatusPending EcsStatus = "PENDING"
        // EcsStatusActivating represents a task being activated
        EcsStatusActivating EcsStatus = "ACTIVATING"
        // EcsStatusRunning represents a task currently running
        EcsStatusRunning EcsStatus = "RUNNING"
        // EcsStatusDeactivating represents a task being deactivated
        EcsStatusDeactivating EcsStatus = "DEACTIVATING"
        // EcsStatusStopping represents a task being stopped
        EcsStatusStopping EcsStatus = "STOPPING"
        // EcsStatusDeprovisioning represents a task being deprovisioned
        EcsStatusDeprovisioning EcsStatus = "DEPROVISIONING"
        // EcsStatusStopped represents a task that has stopped
        EcsStatusStopped EcsStatus = "STOPPED"
)

// ExecutionStatus represents the business-level status of a command execution.
// This is distinct from EcsStatus, which reflects the AWS ECS task lifecycle.
// Execution statuses are used throughout the API and stored in the database.
type ExecutionStatus string

const (
        // ExecutionRunning indicates the command is currently executing
        ExecutionRunning ExecutionStatus = "RUNNING"
        // ExecutionSucceeded indicates the command completed successfully
        ExecutionSucceeded ExecutionStatus = "SUCCEEDED"
        // ExecutionFailed indicates the command failed with an error
        ExecutionFailed ExecutionStatus = "FAILED"
        // ExecutionStopped indicates the command was manually terminated
        ExecutionStopped ExecutionStatus = "STOPPED"
)

// TerminalExecutionStatuses returns all statuses that represent completed executions
func TerminalExecutionStatuses() []ExecutionStatus <span class="cov8" title="1">{
        return []ExecutionStatus{
                ExecutionSucceeded,
                ExecutionFailed,
                ExecutionStopped,
        }
}</span>

// DefaultWebviewerURL is the default URL of the webviewer HTML file.
// This can be overridden via configuration (RUNVOY_WEBVIEWER_URL env var or config file).
const DefaultWebviewerURL = "https://runvoy-releases.s3.us-east-2.amazonaws.com/webviewer.html"

// WebviewerURL is deprecated. Use config.Config.WebviewerURL or constants.DefaultWebviewerURL instead.
// Kept for backward compatibility.
const WebviewerURL = DefaultWebviewerURL

// ClaimURLExpirationMinutes is the number of minutes after which a claim URL expires
const ClaimURLExpirationMinutes = 15

// ClaimEndpointPath is the HTTP path for claiming API keys
const ClaimEndpointPath = "/claim"

// TaskDefinitionFamilyPrefix is the prefix for all runvoy task definition families
// Task definitions are named: {ProjectName}-image-{sanitized-image-name}
// e.g., "runvoy-image-hashicorp-terraform-1-6" for image "hashicorp/terraform:1.6"
const TaskDefinitionFamilyPrefix = "runvoy-image"

// TaskDefinitionIsDefaultTagKey is the ECS tag key used to mark a task definition as the default image
const TaskDefinitionIsDefaultTagKey = "IsDefault"

// TaskDefinitionDockerImageTagKey is the ECS tag key used to store the Docker image name for metadata
const TaskDefinitionDockerImageTagKey = "DockerImage"

// TaskDefinitionIsDefaultTagValue is the tag value used to mark a task definition as the default image
const TaskDefinitionIsDefaultTagValue = "true"

// StartTimeCtxKeyType is the type for start time context keys
type StartTimeCtxKeyType string

// StartTimeCtxKey is the key used to store the start time in context
const StartTimeCtxKey StartTimeCtxKeyType = "startTime"

// Time-related constants

// ServerReadTimeout is the HTTP server read timeout
const ServerReadTimeout = 15 * time.Second

// ServerWriteTimeout is the HTTP server write timeout
const ServerWriteTimeout = 15 * time.Second

// ServerIdleTimeout is the HTTP server idle timeout
const ServerIdleTimeout = 60 * time.Second

// ServerShutdownTimeout is the timeout for graceful server shutdown
const ServerShutdownTimeout = 5 * time.Second

// DefaultContextTimeout is the default timeout for context operations
const DefaultContextTimeout = 10 * time.Second

// ScriptContextTimeout is the timeout for script context operations
const ScriptContextTimeout = 10 * time.Second

// LongScriptContextTimeout is the timeout for longer script context operations
const LongScriptContextTimeout = 30 * time.Second

// TestContextTimeout is the timeout for test contexts
const TestContextTimeout = 5 * time.Second

// SpinnerTickerInterval is the interval between spinner frame updates
const SpinnerTickerInterval = 80 * time.Millisecond

// HTTP status code constants

// HTTPStatusBadRequest is the HTTP status code for bad requests (400)
const HTTPStatusBadRequest = 400

// HTTPStatusServerError is the HTTP status code for server errors (500)
const HTTPStatusServerError = 500

// File permission constants

// ConfigDirPermissions is the file system permissions for config directory (0750)
const ConfigDirPermissions = 0750

// ConfigFilePermissions is the file system permissions for config file (0600)
const ConfigFilePermissions = 0600

// Byte size constants

// APIKeyByteSize is the number of random bytes used to generate API keys
const APIKeyByteSize = 24

// SecretTokenByteSize is the number of random bytes used to generate secret tokens
const SecretTokenByteSize = 24

// RequestIDByteSize is the number of random bytes used to generate request IDs
const RequestIDByteSize = 16

// AWS/CloudWatch constants

// CloudWatchLogsDescribeLimit is the limit for CloudWatch Logs DescribeLogStreams API
const CloudWatchLogsDescribeLimit = int32(50)

// CloudWatchLogsEventsLimit is the limit for CloudWatch Logs GetLogEvents API
const CloudWatchLogsEventsLimit = int32(10000)

// ECSTaskDefinitionMaxResults is the maximum number of results for ECS ListTaskDefinitions
const ECSTaskDefinitionMaxResults = int32(100)

// ECSEphemeralStorageSizeGiB is the ECS ephemeral storage size in GiB
const ECSEphemeralStorageSizeGiB = 21

// UI/Display constants

// HeaderSeparatorLength is the length of the header separator line
const HeaderSeparatorLength = 50

// ProgressBarWidth is the default width for progress bars
const ProgressBarWidth = 40

// BoxBorderPadding is the padding used in box borders
const BoxBorderPadding = 2

// Conversion constants

// MillisecondsPerSecond is the number of milliseconds in a second
const MillisecondsPerSecond = 1000

// PercentageMultiplier is the multiplier to convert fraction to percentage
const PercentageMultiplier = 100

// SecondsPerMinute is the number of seconds in a minute
const SecondsPerMinute = 60

// MinutesPerHour is the number of minutes in an hour
const MinutesPerHour = 60

// Slice/Array capacity constants

// ExecutionsSliceInitialCapacity is the initial capacity for executions slices
const ExecutionsSliceInitialCapacity = 64

// String split constants

// EnvVarSplitLimit is the limit for splitting environment variable strings (KEY=VALUE)
const EnvVarSplitLimit = 2

// Regex match count constants

// RegexMatchCountEnvVar is the expected number of regex matches for environment variable parsing
const RegexMatchCountEnvVar = 3

// Argument validation constants

// ExpectedArgsCreateConfigFile is the expected number of arguments for create-config-file script
const ExpectedArgsCreateConfigFile = 2

// ExpectedArgsSeedAdminUser is the expected number of arguments for seed-admin-user script
const ExpectedArgsSeedAdminUser = 3

// MinimumArgsUpdateReadmeHelp is the minimum number of arguments for update-readme-help script
const MinimumArgsUpdateReadmeHelp = 2
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package dynamodb implements DynamoDB-based storage for runvoy.
// It provides persistence for execution records using AWS DynamoDB.
package dynamodb

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "slices"
        "time"

        "runvoy/internal/api"
        "runvoy/internal/constants"
        apperrors "runvoy/internal/errors"
        "runvoy/internal/logger"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// ExecutionRepository implements the database.ExecutionRepository interface using DynamoDB.
type ExecutionRepository struct {
        client    *dynamodb.Client
        tableName string
        logger    *slog.Logger
}

// NewExecutionRepository creates a new DynamoDB-backed execution repository.
func NewExecutionRepository(client *dynamodb.Client, tableName string, log *slog.Logger) *ExecutionRepository <span class="cov8" title="1">{
        return &amp;ExecutionRepository{
                client:    client,
                tableName: tableName,
                logger:    log,
        }
}</span>

// executionItem represents the structure stored in DynamoDB.
// This keeps the database schema separate from the API types.
type executionItem struct {
        ExecutionID     string     `dynamodbav:"execution_id"`
        StartedAt       time.Time  `dynamodbav:"started_at"`
        UserEmail       string     `dynamodbav:"user_email"`
        Command         string     `dynamodbav:"command"`
        LockName        string     `dynamodbav:"lock_name,omitempty"`
        Status          string     `dynamodbav:"status"`
        CompletedAt     *time.Time `dynamodbav:"completed_at,omitempty"`
        ExitCode        int        `dynamodbav:"exit_code,omitempty"`
        DurationSecs    int        `dynamodbav:"duration_seconds,omitempty"`
        LogStreamName   string     `dynamodbav:"log_stream_name,omitempty"`
        RequestID       string     `dynamodbav:"request_id,omitempty"`
        ComputePlatform string     `dynamodbav:"compute_platform,omitempty"`
}

// toExecutionItem converts an api.Execution to an executionItem.
func toExecutionItem(e *api.Execution) *executionItem <span class="cov8" title="1">{
        return &amp;executionItem{
                ExecutionID:     e.ExecutionID,
                StartedAt:       e.StartedAt,
                UserEmail:       e.UserEmail,
                Command:         e.Command,
                LockName:        e.LockName,
                Status:          e.Status,
                CompletedAt:     e.CompletedAt,
                ExitCode:        e.ExitCode,
                DurationSecs:    e.DurationSeconds,
                LogStreamName:   e.LogStreamName,
                RequestID:       e.RequestID,
                ComputePlatform: e.ComputePlatform,
        }
}</span>

// toAPIExecution converts an executionItem to an api.Execution.
func (e *executionItem) toAPIExecution() *api.Execution <span class="cov8" title="1">{
        return &amp;api.Execution{
                ExecutionID:     e.ExecutionID,
                StartedAt:       e.StartedAt,
                UserEmail:       e.UserEmail,
                Command:         e.Command,
                LockName:        e.LockName,
                Status:          e.Status,
                CompletedAt:     e.CompletedAt,
                ExitCode:        e.ExitCode,
                DurationSeconds: e.DurationSecs,
                LogStreamName:   e.LogStreamName,
                ComputePlatform: e.ComputePlatform,
        }
}</span>

// CreateExecution stores a new execution record in DynamoDB.
func (r *ExecutionRepository) CreateExecution(ctx context.Context, execution *api.Execution) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        item := toExecutionItem(execution)

        av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrDatabaseError("failed to marshal execution", err)
        }</span>

        <span class="cov0" title="0">reqLogger.Debug("calling external service", "context", map[string]string{
                "operation":   "DynamoDB.PutItem",
                "table":       r.tableName,
                "executionID": execution.ExecutionID,
                "userEmail":   execution.UserEmail,
                "status":      execution.Status,
        })

        // Ensure uniqueness: only create if this PK does not already exist
        _, err = r.client.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName: aws.String(r.tableName),
                Item:      av,
                // This condition prevents overwriting an existing item with the same
                // composite key (execution_id, started_at). If an item exists, DynamoDB
                // returns a ConditionalCheckFailedException, which we map to a conflict.
                ConditionExpression: aws.String("attribute_not_exists(execution_id) AND attribute_not_exists(started_at)"),
        })

        if err != nil </span><span class="cov0" title="0">{
                // If the condition failed, surface a conflict indicating duplicate execution ID
                var ccfe *types.ConditionalCheckFailedException
                if errors.As(err, &amp;ccfe) </span><span class="cov0" title="0">{
                        return apperrors.ErrConflict("execution already exists", err)
                }</span>
                <span class="cov0" title="0">return apperrors.ErrDatabaseError("failed to create execution", err)</span>
        }

        <span class="cov0" title="0">reqLogger.Debug("execution stored successfully", "executionID", execution.ExecutionID)

        return nil</span>
}

// GetExecution retrieves an execution by its execution ID.
func (r *ExecutionRepository) GetExecution(ctx context.Context, executionID string) (*api.Execution, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Log before calling DynamoDB Query
        logArgs := []any{
                "operation", "DynamoDB.Query",
                "table", r.tableName,
                "executionID", executionID,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        result, err := r.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(r.tableName),
                KeyConditionExpression: aws.String("execution_id = :execution_id"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":execution_id": &amp;types.AttributeValueMemberS{Value: executionID},
                },
                ScanIndexForward: aws.Bool(false), // sort descending by started_at
                Limit:            aws.Int32(1),
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to query execution", err)
        }</span>

        <span class="cov0" title="0">if len(result.Items) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var item executionItem
        if err = attributevalue.UnmarshalMap(result.Items[0], &amp;item); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to unmarshal execution", err)
        }</span>

        <span class="cov0" title="0">return item.toAPIExecution(), nil</span>
}

// marshallTimestamp marshals a timestamp to a DynamoDB attribute value string.
func marshallTimestamp(t time.Time) (string, error) <span class="cov8" title="1">{
        timestampAV, err := attributevalue.Marshal(t)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrDatabaseError("failed to marshal timestamp", err)
        }</span>
        <span class="cov8" title="1">timestampStr, ok := timestampAV.(*types.AttributeValueMemberS)
        if !ok </span><span class="cov0" title="0">{
                return "", apperrors.ErrDatabaseError("timestamp is not a string attribute", nil)
        }</span>
        <span class="cov8" title="1">return timestampStr.Value, nil</span>
}

// buildUpdateExpression builds a DynamoDB update expression for an execution.
func buildUpdateExpression(
        execution *api.Execution,
) (updateExpr string, exprNames map[string]string, exprValues map[string]types.AttributeValue, err error) <span class="cov8" title="1">{
        updateExpr = "SET #status = :status"
        exprNames = map[string]string{
                "#status": "status",
        }
        exprAttrValues := map[string]types.AttributeValue{
                ":status": &amp;types.AttributeValueMemberS{Value: execution.Status},
        }

        if execution.CompletedAt != nil </span><span class="cov8" title="1">{
                updateExpr += ", completed_at = :completed_at"
                completedAtStr, marshalErr := marshallTimestamp(*execution.CompletedAt)
                if marshalErr != nil </span><span class="cov0" title="0">{
                        return "", nil, nil, marshalErr
                }</span>
                <span class="cov8" title="1">exprAttrValues[":completed_at"] = &amp;types.AttributeValueMemberS{Value: completedAtStr}</span>
        }

        <span class="cov8" title="1">updateExpr += ", exit_code = :exit_code"
        exprAttrValues[":exit_code"] = &amp;types.AttributeValueMemberN{Value: fmt.Sprintf("%d", execution.ExitCode)}

        if execution.DurationSeconds &gt; 0 </span><span class="cov8" title="1">{
                updateExpr += ", duration_seconds = :duration_seconds"
                exprAttrValues[":duration_seconds"] = &amp;types.AttributeValueMemberN{
                        Value: fmt.Sprintf("%d", execution.DurationSeconds)}
        }</span>

        <span class="cov8" title="1">if execution.LogStreamName != "" </span><span class="cov8" title="1">{
                updateExpr += ", log_stream_name = :log_stream_name"
                exprAttrValues[":log_stream_name"] = &amp;types.AttributeValueMemberS{Value: execution.LogStreamName}
        }</span>

        <span class="cov8" title="1">return updateExpr, exprNames, exprAttrValues, nil</span>
}

// UpdateExecution updates an existing execution record.
func (r *ExecutionRepository) UpdateExecution(ctx context.Context, execution *api.Execution) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        updateExpr, exprAttrNames, exprAttrValues, err := buildUpdateExpression(execution)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">startedAtStr, err := marshallTimestamp(execution.StartedAt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">updateLogArgs := []any{
                "operation", "DynamoDB.UpdateItem",
                "table", r.tableName,
                "executionID", execution.ExecutionID,
                "status", execution.Status,
                "updateExpression", updateExpr,
        }
        updateLogArgs = append(updateLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(updateLogArgs))

        _, err = r.client.UpdateItem(ctx, &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(r.tableName),
                Key: map[string]types.AttributeValue{
                        "execution_id": &amp;types.AttributeValueMemberS{Value: execution.ExecutionID},
                        "started_at":   &amp;types.AttributeValueMemberS{Value: startedAtStr},
                },
                UpdateExpression:          aws.String(updateExpr),
                ExpressionAttributeNames:  exprAttrNames,
                ExpressionAttributeValues: exprAttrValues,
        })

        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrDatabaseError("failed to update execution", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListExecutions scans the executions table to return all execution records.
// Results are sorted by StartedAt descending in-memory to provide a reasonable default ordering.
func (r *ExecutionRepository) ListExecutions(ctx context.Context) ([]*api.Execution, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)
        executions := make([]*api.Execution, 0, constants.ExecutionsSliceInitialCapacity)
        var lastKey map[string]types.AttributeValue
        pageCount := 0

        reqLogger.Debug("calling external service", "context", map[string]string{
                "operation": "DynamoDB.Scan",
                "table":     r.tableName,
                "paginated": "true",
        })

        for </span><span class="cov0" title="0">{
                pageCount++

                out, err := r.client.Scan(ctx, &amp;dynamodb.ScanInput{
                        TableName:         aws.String(r.tableName),
                        ExclusiveStartKey: lastKey,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperrors.ErrDatabaseError("failed to scan executions", err)
                }</span>

                <span class="cov0" title="0">for _, it := range out.Items </span><span class="cov0" title="0">{
                        var item executionItem
                        if err = attributevalue.UnmarshalMap(it, &amp;item); err != nil </span><span class="cov0" title="0">{
                                return nil, apperrors.ErrDatabaseError("failed to unmarshal execution", err)
                        }</span>
                        <span class="cov0" title="0">executions = append(executions, item.toAPIExecution())</span>
                }

                <span class="cov0" title="0">if len(out.LastEvaluatedKey) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">lastKey = out.LastEvaluatedKey</span>
        }

        // Sort by StartedAt descending (newest first)
        <span class="cov0" title="0">slices.SortFunc(executions, func(a, b *api.Execution) int </span><span class="cov0" title="0">{
                if a.StartedAt.Equal(b.StartedAt) </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">if a.StartedAt.After(b.StartedAt) </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return 1</span>
        })

        <span class="cov0" title="0">return executions, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package dynamodb

import (
        "context"
        stderrors "errors"
        "fmt"
        "log/slog"
        "time"

        "runvoy/internal/api"
        apperrors "runvoy/internal/errors"
        "runvoy/internal/logger"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// UserRepository implements the database.UserRepository interface using DynamoDB.
type UserRepository struct {
        client           *dynamodb.Client
        tableName        string
        pendingTableName string
        logger           *slog.Logger
}

// NewUserRepository creates a new DynamoDB-backed user repository.
func NewUserRepository(
        client *dynamodb.Client,
        tableName string,
        pendingTableName string,
        log *slog.Logger,
) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                client:           client,
                tableName:        tableName,
                pendingTableName: pendingTableName,
                logger:           log,
        }
}</span>

// userItem represents the structure stored in DynamoDB.
// This keeps the database schema separate from the API types.
type userItem struct {
        APIKeyHash string    `dynamodbav:"api_key_hash"`
        UserEmail  string    `dynamodbav:"user_email"`
        CreatedAt  time.Time `dynamodbav:"created_at"`
        LastUsed   time.Time `dynamodbav:"last_used,omitempty"`
        Revoked    bool      `dynamodbav:"revoked"`
        ExpiresAt  int64     `dynamodbav:"expires_at,omitempty"` // Unix timestamp for TTL
}

// CreateUser stores a new user with their hashed API key in DynamoDB.
func (r *UserRepository) CreateUser(ctx context.Context, user *api.User, apiKeyHash string) error <span class="cov0" title="0">{
        return r.CreateUserWithExpiration(ctx, user, apiKeyHash, 0)
}</span>

// CreateUserWithExpiration stores a new user with their hashed API key and optional TTL in DynamoDB.
// If expiresAtUnix is 0, no TTL is set. If expiresAtUnix is &gt; 0, it sets the expires_at field for automatic deletion.
func (r *UserRepository) CreateUserWithExpiration(
        ctx context.Context,
        user *api.User,
        apiKeyHash string,
        expiresAtUnix int64,
) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Create the item to store
        item := userItem{
                APIKeyHash: apiKeyHash,
                UserEmail:  user.Email,
                CreatedAt:  user.CreatedAt,
                Revoked:    false,
        }

        // Only set ExpiresAt if provided
        if expiresAtUnix &gt; 0 </span><span class="cov0" title="0">{
                item.ExpiresAt = expiresAtUnix
        }</span>

        <span class="cov0" title="0">av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Log before calling DynamoDB PutItem
        <span class="cov0" title="0">logArgs := []any{
                "operation", "DynamoDB.PutItem",
                "table", r.tableName,
                "userEmail", user.Email,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        // Use ConditionExpression to ensure we don't overwrite existing users
        _, err = r.client.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName:           aws.String(r.tableName),
                Item:                av,
                ConditionExpression: aws.String("attribute_not_exists(api_key_hash)"),
        })

        if err != nil </span><span class="cov0" title="0">{
                var ccf *types.ConditionalCheckFailedException
                if stderrors.As(err, &amp;ccf) </span><span class="cov0" title="0">{
                        return apperrors.ErrConflict("user with this API key already exists", nil)
                }</span>
                <span class="cov0" title="0">return apperrors.ErrDatabaseError("failed to create user", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetUserByEmail retrieves a user by their email using the GSI.
func (r *UserRepository) GetUserByEmail(ctx context.Context, email string) (*api.User, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Log before calling DynamoDB Query
        logArgs := []any{
                "operation", "DynamoDB.Query",
                "table", r.tableName,
                "index", "user_email-index",
                "email", email,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        result, err := r.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(r.tableName),
                IndexName:              aws.String("user_email-index"),
                KeyConditionExpression: aws.String("user_email = :email"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":email": &amp;types.AttributeValueMemberS{Value: email},
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to query user by email", err)
        }</span>

        <span class="cov0" title="0">if len(result.Items) == 0 </span><span class="cov0" title="0">{
                reqLogger.Debug("user not found", "email", email)

                return nil, nil
        }</span>

        <span class="cov0" title="0">var item userItem
        if unmarshalErr := attributevalue.UnmarshalMap(result.Items[0], &amp;item); unmarshalErr != nil </span><span class="cov0" title="0">{
                return nil, unmarshalErr
        }</span>

        <span class="cov0" title="0">return &amp;api.User{
                Email:     item.UserEmail,
                CreatedAt: item.CreatedAt,
                Revoked:   item.Revoked,
                LastUsed:  item.LastUsed,
                // Note: APIKey is intentionally omitted for security
        }, nil</span>
}

// GetUserByAPIKeyHash retrieves a user by their hashed API key (primary key).
func (r *UserRepository) GetUserByAPIKeyHash(ctx context.Context, apiKeyHash string) (*api.User, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Log before calling DynamoDB GetItem
        logArgs := []any{
                "operation", "DynamoDB.GetItem",
                "table", r.tableName,
                "apiKeyHash", apiKeyHash,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        result, err := r.client.GetItem(ctx, &amp;dynamodb.GetItemInput{
                TableName: aws.String(r.tableName),
                Key: map[string]types.AttributeValue{
                        "api_key_hash": &amp;types.AttributeValueMemberS{Value: apiKeyHash},
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Debug("failed to get user by API key hash", "error", err)

                return nil, apperrors.ErrDatabaseError("failed to get user by API key hash", err)
        }</span>

        <span class="cov0" title="0">if result.Item == nil </span><span class="cov0" title="0">{
                reqLogger.Debug("user not found", "apiKeyHash", apiKeyHash)

                return nil, nil
        }</span>

        <span class="cov0" title="0">var item userItem
        if unmarshalErr := attributevalue.UnmarshalMap(result.Item, &amp;item); unmarshalErr != nil </span><span class="cov0" title="0">{
                return nil, unmarshalErr
        }</span>

        <span class="cov0" title="0">return &amp;api.User{
                Email:     item.UserEmail,
                CreatedAt: item.CreatedAt,
                Revoked:   item.Revoked,
                LastUsed:  item.LastUsed,
        }, nil</span>
}

// queryAPIKeyHashByEmail queries for the api_key_hash by email.
func (r *UserRepository) queryAPIKeyHashByEmail(ctx context.Context, email, purpose string) (string, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        queryLogArgs := []any{
                "operation", "DynamoDB.Query",
                "table", r.tableName,
                "index", "user_email-index",
                "email", email,
                "purpose", purpose,
        }
        queryLogArgs = append(queryLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(queryLogArgs))

        result, err := r.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(r.tableName),
                IndexName:              aws.String("user_email-index"),
                KeyConditionExpression: aws.String("user_email = :email"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":email": &amp;types.AttributeValueMemberS{Value: email},
                },
                Limit: aws.Int32(1),
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", apperrors.ErrDatabaseError("failed to query user by email", err)
        }</span>

        <span class="cov0" title="0">if len(result.Items) == 0 </span><span class="cov0" title="0">{
                return "", apperrors.ErrNotFound("user not found", nil)
        }</span>

        <span class="cov0" title="0">var apiKeyHash string
        if v, hasKey := result.Items[0]["api_key_hash"]; hasKey </span><span class="cov0" title="0">{
                if s, isString := v.(*types.AttributeValueMemberS); isString </span><span class="cov0" title="0">{
                        apiKeyHash = s.Value
                }</span>
        }
        <span class="cov0" title="0">if apiKeyHash == "" </span><span class="cov0" title="0">{
                return "", apperrors.ErrDatabaseError("user record missing api_key_hash attribute", nil)
        }</span>

        <span class="cov0" title="0">return apiKeyHash, nil</span>
}

// UpdateLastUsed updates the last_used timestamp for a user.
func (r *UserRepository) UpdateLastUsed(ctx context.Context, email string) (*time.Time, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        apiKeyHash, err := r.queryAPIKeyHashByEmail(ctx, email, "last_used_update")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">now := time.Now().UTC()

        updateLogArgs := []any{
                "operation", "DynamoDB.UpdateItem",
                "table", r.tableName,
                "email", email,
                "apiKeyHash", apiKeyHash,
        }
        updateLogArgs = append(updateLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(updateLogArgs))

        _, err = r.client.UpdateItem(ctx, &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(r.tableName),
                Key: map[string]types.AttributeValue{
                        "api_key_hash": &amp;types.AttributeValueMemberS{Value: apiKeyHash},
                },
                UpdateExpression: aws.String("SET last_used = :now"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":now": &amp;types.AttributeValueMemberS{
                                Value: now.Format(time.RFC3339Nano)}},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to update last_used", err)
        }</span>

        <span class="cov0" title="0">return &amp;now, nil</span>
}

// RevokeUser marks a user's API key as revoked.
func (r *UserRepository) RevokeUser(ctx context.Context, email string) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        apiKeyHash, err := r.queryAPIKeyHashByEmail(ctx, email, "revoke_user")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">updateLogArgs := []any{
                "operation", "DynamoDB.UpdateItem",
                "table", r.tableName,
                "email", email,
                "apiKeyHash", apiKeyHash,
                "action", "revoke",
        }
        updateLogArgs = append(updateLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(updateLogArgs))

        _, err = r.client.UpdateItem(ctx, &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(r.tableName),
                Key: map[string]types.AttributeValue{
                        "api_key_hash": &amp;types.AttributeValueMemberS{Value: apiKeyHash},
                },
                UpdateExpression: aws.String("SET revoked = :revoked"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":revoked": &amp;types.AttributeValueMemberBOOL{Value: true},
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrDatabaseError("failed to revoke user", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveExpiration removes the expires_at field from a user record, making them permanent.
func (r *UserRepository) RemoveExpiration(ctx context.Context, email string) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // First, get the user's api_key_hash
        queryLogArgs := []any{
                "operation", "DynamoDB.Query",
                "table", r.tableName,
                "index", "user_email-index",
                "email", email,
                "purpose", "remove_expiration",
        }
        queryLogArgs = append(queryLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(queryLogArgs))

        result, err := r.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(r.tableName),
                IndexName:              aws.String("user_email-index"),
                KeyConditionExpression: aws.String("user_email = :email"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":email": &amp;types.AttributeValueMemberS{Value: email},
                },
                Limit: aws.Int32(1),
        })
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrDatabaseError("failed to query user by email for expiration removal", err)
        }</span>

        <span class="cov0" title="0">if len(result.Items) == 0 </span><span class="cov0" title="0">{
                return apperrors.ErrNotFound("user not found", nil)
        }</span>

        <span class="cov0" title="0">var apiKeyHash string
        if v, hasKey := result.Items[0]["api_key_hash"]; hasKey </span><span class="cov0" title="0">{
                if s, isString := v.(*types.AttributeValueMemberS); isString </span><span class="cov0" title="0">{
                        apiKeyHash = s.Value
                }</span>
        }

        // Log before calling DynamoDB UpdateItem
        <span class="cov0" title="0">updateLogArgs := []any{
                "operation", "DynamoDB.UpdateItem",
                "table", r.tableName,
                "email", email,
                "apiKeyHash", apiKeyHash,
                "action", "remove_expiration",
        }
        updateLogArgs = append(updateLogArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(updateLogArgs))

        // Remove the expires_at attribute
        _, err = r.client.UpdateItem(ctx, &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(r.tableName),
                Key: map[string]types.AttributeValue{
                        "api_key_hash": &amp;types.AttributeValueMemberS{Value: apiKeyHash},
                },
                UpdateExpression: aws.String("REMOVE expires_at"),
        })

        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrDatabaseError("failed to remove expiration", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// pendingAPIKeyItem represents the structure stored in DynamoDB.
type pendingAPIKeyItem struct {
        SecretToken  string `dynamodbav:"secret_token"`
        APIKey       string `dynamodbav:"api_key"`
        UserEmail    string `dynamodbav:"user_email"`
        CreatedBy    string `dynamodbav:"created_by"`
        CreatedAt    int64  `dynamodbav:"created_at"` // Unix timestamp
        ExpiresAt    int64  `dynamodbav:"expires_at"` // Unix timestamp for TTL
        Viewed       bool   `dynamodbav:"viewed"`
        ViewedAt     *int64 `dynamodbav:"viewed_at,omitempty"` // Unix timestamp when viewed
        ViewedFromIP string `dynamodbav:"viewed_from_ip,omitempty"`
}

// CreatePendingAPIKey stores a pending API key with a secret token.
func (r *UserRepository) CreatePendingAPIKey(ctx context.Context, pending *api.PendingAPIKey) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Create the item to store
        item := pendingAPIKeyItem{
                SecretToken: pending.SecretToken,
                APIKey:      pending.APIKey,
                UserEmail:   pending.UserEmail,
                CreatedBy:   pending.CreatedBy,
                CreatedAt:   pending.CreatedAt.Unix(),
                ExpiresAt:   pending.ExpiresAt,
                Viewed:      false,
        }

        av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrInternalError("failed to marshal pending API key", err)
        }</span>

        // Log before calling DynamoDB PutItem
        <span class="cov0" title="0">logArgs := []any{
                "operation", "DynamoDB.PutItem",
                "table", r.pendingTableName,
                "userEmail", pending.UserEmail,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        _, err = r.client.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName: aws.String(r.pendingTableName),
                Item:      av,
        })

        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrDatabaseError("failed to create pending API key", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetPendingAPIKey retrieves a pending API key by its secret token.
func (r *UserRepository) GetPendingAPIKey(ctx context.Context, secretToken string) (*api.PendingAPIKey, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Log before calling DynamoDB GetItem
        logArgs := []any{
                "operation", "DynamoDB.GetItem",
                "table", r.pendingTableName,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        result, err := r.client.GetItem(ctx, &amp;dynamodb.GetItemInput{
                TableName: aws.String(r.pendingTableName),
                Key: map[string]types.AttributeValue{
                        "secret_token": &amp;types.AttributeValueMemberS{Value: secretToken},
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to get pending API key", err)
        }</span>

        <span class="cov0" title="0">if result.Item == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var item pendingAPIKeyItem
        if err = attributevalue.UnmarshalMap(result.Item, &amp;item); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInternalError("failed to unmarshal pending API key", err)
        }</span>

        // Convert back to API type
        <span class="cov0" title="0">pending := &amp;api.PendingAPIKey{
                SecretToken:  item.SecretToken,
                APIKey:       item.APIKey,
                UserEmail:    item.UserEmail,
                CreatedBy:    item.CreatedBy,
                CreatedAt:    time.Unix(item.CreatedAt, 0),
                ExpiresAt:    item.ExpiresAt,
                Viewed:       item.Viewed,
                ViewedFromIP: item.ViewedFromIP,
        }

        // Convert ViewedAt if present
        if item.ViewedAt != nil </span><span class="cov0" title="0">{
                viewedAt := time.Unix(*item.ViewedAt, 0)
                pending.ViewedAt = &amp;viewedAt
        }</span>

        <span class="cov0" title="0">return pending, nil</span>
}

// MarkAsViewed atomically marks a pending key as viewed with the IP address.
func (r *UserRepository) MarkAsViewed(ctx context.Context, secretToken, ipAddress string) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Log before calling DynamoDB UpdateItem
        logArgs := []any{
                "operation", "DynamoDB.UpdateItem",
                "table", r.pendingTableName,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        viewedAt := time.Now().Unix()
        _, err := r.client.UpdateItem(ctx, &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(r.pendingTableName),
                Key: map[string]types.AttributeValue{
                        "secret_token": &amp;types.AttributeValueMemberS{Value: secretToken},
                },
                UpdateExpression:    aws.String("SET viewed = :true, viewed_at = :viewedAt, viewed_from_ip = :ip"),
                ConditionExpression: aws.String("attribute_exists(secret_token) AND viewed = :false"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":true":     &amp;types.AttributeValueMemberBOOL{Value: true},
                        ":false":    &amp;types.AttributeValueMemberBOOL{Value: false},
                        ":viewedAt": &amp;types.AttributeValueMemberN{Value: fmt.Sprintf("%d", viewedAt)},
                        ":ip":       &amp;types.AttributeValueMemberS{Value: ipAddress},
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                var ccf *types.ConditionalCheckFailedException
                if stderrors.As(err, &amp;ccf) </span><span class="cov0" title="0">{
                        return apperrors.ErrConflict("pending key already viewed or does not exist", nil)
                }</span>
                <span class="cov0" title="0">return apperrors.ErrDatabaseError("failed to mark pending key as viewed", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// DeletePendingAPIKey removes a pending API key from the database.
func (r *UserRepository) DeletePendingAPIKey(ctx context.Context, secretToken string) error <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Log before calling DynamoDB DeleteItem
        logArgs := []any{
                "operation", "DynamoDB.DeleteItem",
                "table", r.pendingTableName,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        _, err := r.client.DeleteItem(ctx, &amp;dynamodb.DeleteItemInput{
                TableName: aws.String(r.pendingTableName),
                Key: map[string]types.AttributeValue{
                        "secret_token": &amp;types.AttributeValueMemberS{Value: secretToken},
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrDatabaseError("failed to delete pending API key", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListUsers returns all users in the system (excluding API key hashes for security).
func (r *UserRepository) ListUsers(ctx context.Context) ([]*api.User, error) <span class="cov0" title="0">{
        reqLogger := logger.DeriveRequestLogger(ctx, r.logger)

        // Log before calling DynamoDB Scan
        logArgs := []any{
                "operation", "DynamoDB.Scan",
                "table", r.tableName,
        }
        logArgs = append(logArgs, logger.GetDeadlineInfo(ctx)...)
        reqLogger.Debug("calling external service", "context", logger.SliceToMap(logArgs))

        result, err := r.client.Scan(ctx, &amp;dynamodb.ScanInput{
                TableName: aws.String(r.tableName),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrDatabaseError("failed to list users", err)
        }</span>

        <span class="cov0" title="0">users := make([]*api.User, 0, len(result.Items))
        for _, item := range result.Items </span><span class="cov0" title="0">{
                var dbUserItem userItem
                if err = attributevalue.UnmarshalMap(item, &amp;dbUserItem); err != nil </span><span class="cov0" title="0">{
                        reqLogger.Warn("failed to unmarshal user item", "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">users = append(users, &amp;api.User{
                        Email:     dbUserItem.UserEmail,
                        CreatedAt: dbUserItem.CreatedAt,
                        Revoked:   dbUserItem.Revoked,
                        LastUsed:  dbUserItem.LastUsed,
                        // Note: APIKey and APIKeyHash are intentionally omitted for security
                })</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package errors provides error types and handling for runvoy.
// It includes custom error types with HTTP status codes and error codes.
package errors

import (
        "errors"
        "fmt"
        "net/http"
)

// AppError represents an application error with an associated HTTP status code.
type AppError struct {
        // Code is an optional error code string for programmatic handling
        Code string
        // Message is a user-friendly error message
        Message string
        // StatusCode is the HTTP status code to return
        StatusCode int
        // Cause is the underlying error (for error wrapping)
        Cause error
}

// Error implements the error interface.
func (e *AppError) Error() string <span class="cov8" title="1">{
        if e.Cause != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %v", e.Message, e.Cause)
        }</span>
        <span class="cov8" title="1">return e.Message</span>
}

// Unwrap returns the underlying error for error unwrapping.
func (e *AppError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// Is allows errors.Is to work with AppError.
func (e *AppError) Is(target error) bool <span class="cov8" title="1">{
        if t, ok := target.(*AppError); ok </span><span class="cov8" title="1">{
                return e.Code != "" &amp;&amp; e.Code == t.Code
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Predefined error codes
const (
        // Client error codes
        ErrCodeInvalidRequest = "INVALID_REQUEST"
        ErrCodeUnauthorized   = "UNAUTHORIZED"
        ErrCodeNotFound       = "NOT_FOUND"
        ErrCodeConflict       = "CONFLICT"
        ErrCodeInvalidAPIKey  = "INVALID_API_KEY" //nolint:gosec
        ErrCodeAPIKeyRevoked  = "API_KEY_REVOKED" //nolint:gosec

        // Server error codes
        ErrCodeInternalError      = "INTERNAL_ERROR"
        ErrCodeDatabaseError      = "DATABASE_ERROR"
        ErrCodeServiceUnavailable = "SERVICE_UNAVAILABLE"
)

// NewClientError creates a new client error (4xx status codes).
func NewClientError(statusCode int, code, message string, cause error) *AppError <span class="cov8" title="1">{
        if statusCode &lt; 400 || statusCode &gt;= 500 </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("NewClientError called with non-client status code: %d", statusCode))</span>
        }
        <span class="cov8" title="1">return &amp;AppError{
                Code:       code,
                Message:    message,
                StatusCode: statusCode,
                Cause:      cause,
        }</span>
}

// NewServerError creates a new server error (5xx status codes).
func NewServerError(statusCode int, code, message string, cause error) *AppError <span class="cov8" title="1">{
        if statusCode &lt; 500 || statusCode &gt;= 600 </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("NewServerError called with non-server status code: %d", statusCode))</span>
        }
        <span class="cov8" title="1">return &amp;AppError{
                Code:       code,
                Message:    message,
                StatusCode: statusCode,
                Cause:      cause,
        }</span>
}

// Convenience constructors for common errors

// ErrUnauthorized creates an unauthorized error (401).
func ErrUnauthorized(message string, cause error) *AppError <span class="cov8" title="1">{
        return NewClientError(http.StatusUnauthorized, ErrCodeUnauthorized, message, cause)
}</span>

// ErrInvalidAPIKey creates an invalid API key error (401).
func ErrInvalidAPIKey(cause error) *AppError <span class="cov8" title="1">{
        return NewClientError(http.StatusUnauthorized, ErrCodeInvalidAPIKey, "Invalid API key", cause)
}</span>

// ErrAPIKeyRevoked creates an API key revoked error (401).
func ErrAPIKeyRevoked(cause error) *AppError <span class="cov8" title="1">{
        return NewClientError(http.StatusUnauthorized, ErrCodeAPIKeyRevoked, "API key has been revoked", cause)
}</span>

// ErrNotFound creates a not found error (404).
func ErrNotFound(message string, cause error) *AppError <span class="cov8" title="1">{
        return NewClientError(http.StatusNotFound, ErrCodeNotFound, message, cause)
}</span>

// ErrConflict creates a conflict error (409).
func ErrConflict(message string, cause error) *AppError <span class="cov8" title="1">{
        return NewClientError(http.StatusConflict, ErrCodeConflict, message, cause)
}</span>

// ErrBadRequest creates a bad request error (400).
func ErrBadRequest(message string, cause error) *AppError <span class="cov8" title="1">{
        return NewClientError(http.StatusBadRequest, ErrCodeInvalidRequest, message, cause)
}</span>

// ErrInternalError creates an internal server error (500).
func ErrInternalError(message string, cause error) *AppError <span class="cov8" title="1">{
        return NewServerError(http.StatusInternalServerError, ErrCodeInternalError, message, cause)
}</span>

// ErrDatabaseError creates a database error (503 Service Unavailable).
// Database failures are typically transient issues.
func ErrDatabaseError(message string, cause error) *AppError <span class="cov8" title="1">{
        return NewServerError(http.StatusServiceUnavailable, ErrCodeDatabaseError, message, cause)
}</span>

// GetStatusCode extracts the HTTP status code from an error.
// Returns 500 if the error is not an AppError.
func GetStatusCode(err error) int <span class="cov8" title="1">{
        var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov8" title="1">{
                return appErr.StatusCode
        }</span>
        <span class="cov8" title="1">return http.StatusInternalServerError</span>
}

// GetErrorCode extracts the error code from an error.
// Returns empty string if the error is not an AppError.
func GetErrorCode(err error) string <span class="cov8" title="1">{
        var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov8" title="1">{
                return appErr.Code
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetErrorMessage extracts a user-friendly message from an error.
func GetErrorMessage(err error) string <span class="cov8" title="1">{
        var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov8" title="1">{
                return appErr.Message
        }</span>
        <span class="cov8" title="1">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package events provides event processing functionality for AWS CloudWatch events,
// particularly for handling ECS task state changes and execution completion notifications.
package events

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "runvoy/internal/constants"
        "runvoy/internal/database"
        "runvoy/internal/logger"

        "github.com/aws/aws-lambda-go/events"
)

// parseTaskTimes parses and validates the task timestamps, calculating duration.
func parseTaskTimes(
        taskEvent *ECSTaskStateChangeEvent, executionStartedAt time.Time, reqLogger *slog.Logger,
) (startedAt, stoppedAt time.Time, durationSeconds int, err error) <span class="cov8" title="1">{
        if taskEvent.StartedAt != "" </span><span class="cov8" title="1">{
                startedAt, err = ParseTime(taskEvent.StartedAt)
                if err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error("failed to parse startedAt timestamp", "error", err, "startedAt", taskEvent.StartedAt)
                        return time.Time{}, time.Time{}, 0, fmt.Errorf("failed to parse startedAt: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                reqLogger.Warn("startedAt missing from task event, using execution's StartedAt",
                        "executionStartedAt", executionStartedAt.Format(time.RFC3339),
                )
                startedAt = executionStartedAt
        }</span>

        <span class="cov8" title="1">stoppedAt, err = ParseTime(taskEvent.StoppedAt)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("failed to parse stoppedAt timestamp", "error", err, "stoppedAt", taskEvent.StoppedAt)
                return time.Time{}, time.Time{}, 0, fmt.Errorf("failed to parse stoppedAt: %w", err)
        }</span>

        <span class="cov8" title="1">durationSeconds = int(stoppedAt.Sub(startedAt).Seconds())
        if durationSeconds &lt; 0 </span><span class="cov0" title="0">{
                reqLogger.Warn("calculated negative duration, setting to 0",
                        "startedAt", startedAt.Format(time.RFC3339),
                        "stoppedAt", stoppedAt.Format(time.RFC3339),
                )
                durationSeconds = 0
        }</span>

        <span class="cov8" title="1">return startedAt, stoppedAt, durationSeconds, nil</span>
}

// handleECSTaskCompletion processes ECS Task State Change events
func (p *Processor) handleECSTaskCompletion(ctx context.Context, event *events.CloudWatchEvent) error <span class="cov8" title="1">{
        reqLogger := logger.DeriveRequestLogger(ctx, p.logger)

        var taskEvent ECSTaskStateChangeEvent
        if err := json.Unmarshal(event.Detail, &amp;taskEvent); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("failed to parse ECS task event", "error", err)
                return fmt.Errorf("failed to parse ECS task event: %w", err)
        }</span>

        <span class="cov8" title="1">executionID := extractExecutionIDFromTaskArn(taskEvent.TaskArn)

        reqLogger.Info("pattern matched, processing ECS task completion",
                "execution", map[string]string{
                        "executionID":   executionID,
                        "startedAt":     taskEvent.StartedAt,
                        "stopCode":      taskEvent.StopCode,
                        "stoppedAt":     taskEvent.StoppedAt,
                        "stoppedReason": taskEvent.StoppedReason,
                        "taskArn":       taskEvent.TaskArn,
                })

        execution, err := p.executionRepo.GetExecution(ctx, executionID)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("failed to get execution", "error", err)
                return fmt.Errorf("failed to get execution: %w", err)
        }</span>

        <span class="cov8" title="1">if execution == nil </span><span class="cov8" title="1">{
                reqLogger.Error("execution not found for task (orphaned task?)",
                        "clusterArn", taskEvent.ClusterArn,
                )
                // Don't fail for orphaned tasks - they might have been started manually?
                // TODO: figure out what to do with orphaned tasks or if we should fail the Lambda
                return nil
        }</span>

        <span class="cov8" title="1">status, exitCode := determineStatusAndExitCode(&amp;taskEvent)
        _, stoppedAt, durationSeconds, err := parseTaskTimes(&amp;taskEvent, execution.StartedAt, reqLogger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">execution.Status = status
        execution.ExitCode = exitCode
        execution.CompletedAt = &amp;stoppedAt
        execution.DurationSeconds = durationSeconds

        if err = p.executionRepo.UpdateExecution(ctx, execution); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("failed to update execution", "error", err)
                return fmt.Errorf("failed to update execution: %w", err)
        }</span>

        <span class="cov8" title="1">reqLogger.Info("execution updated successfully", "execution", execution)

        return nil</span>
}

// extractExecutionIDFromTaskArn extracts the execution ID from a task ARN
// Task ARN format: arn:aws:ecs:region:account:task/cluster-name/EXECUTION_ID
func extractExecutionIDFromTaskArn(taskArn string) string <span class="cov8" title="1">{
        parts := strings.Split(taskArn, "/")
        return parts[len(parts)-1]
}</span>

// determineStatusAndExitCode determines the final status and exit code from the task event
func determineStatusAndExitCode(event *ECSTaskStateChangeEvent) (status string, exitCode int) <span class="cov8" title="1">{
        // Default values
        status = string(constants.ExecutionFailed)
        exitCode = 1

        // Check stop code first
        switch event.StopCode </span>{
        case "UserInitiated":<span class="cov8" title="1">
                status = string(constants.ExecutionStopped)
                exitCode = 130 // Standard exit code for SIGINT/manual termination
                return status, exitCode</span>
        case "TaskFailedToStart":<span class="cov8" title="1">
                status = string(constants.ExecutionFailed)
                exitCode = 1
                return status, exitCode</span>
        }

        // Find the main runner container by name and get its exit code
        <span class="cov8" title="1">for _, container := range event.Containers </span><span class="cov8" title="1">{
                if container.Name == constants.RunnerContainerName </span><span class="cov8" title="1">{
                        if container.ExitCode != nil </span><span class="cov8" title="1">{
                                exitCode = *container.ExitCode
                                if exitCode == 0 </span><span class="cov8" title="1">{
                                        status = string(constants.ExecutionSucceeded)
                                }</span> else<span class="cov8" title="1"> {
                                        status = string(constants.ExecutionFailed)
                                }</span>
                                <span class="cov8" title="1">return status, exitCode</span>
                        }
                        // Runner container found but no exit code available
                        <span class="cov8" title="1">break</span>
                }
        }

        // If we reach here, we don't have a clear exit code
        // Use stop code to determine status
        <span class="cov8" title="1">if event.StopCode == "EssentialContainerExited" </span><span class="cov8" title="1">{
                // Container exited but we don't have the exit code
                // Assume failure since we should have the exit code for success
                status = string(constants.ExecutionFailed)
                exitCode = 1
        }</span>

        <span class="cov8" title="1">return status, exitCode</span>
}

// ECSCompletionHandler is a factory function that returns a handler for ECS completion events
func ECSCompletionHandler(
        executionRepo database.ExecutionRepository,
        log *slog.Logger) func(context.Context, events.CloudWatchEvent) error <span class="cov8" title="1">{
        return func(ctx context.Context, event events.CloudWatchEvent) error </span><span class="cov8" title="1">{
                p := &amp;Processor{
                        executionRepo: executionRepo,
                        logger:        log,
                }
                return p.handleECSTaskCompletion(ctx, &amp;event)
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package events

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"

        "runvoy/internal/config"
        "runvoy/internal/database"
        dynamorepo "runvoy/internal/database/dynamodb"
        "runvoy/internal/logger"

        "github.com/aws/aws-lambda-go/events"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
)

// Processor handles async events from EventBridge
type Processor struct {
        executionRepo database.ExecutionRepository
        logger        *slog.Logger
}

// NewProcessor creates a new event processor with AWS backend
func NewProcessor(ctx context.Context, cfg *config.Config, log *slog.Logger) (*Processor, error) <span class="cov0" title="0">{
        if cfg.ExecutionsTable == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ExecutionsTable cannot be empty")
        }</span>

        // Load AWS configuration
        <span class="cov0" title="0">awsCfg, err := awsconfig.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load AWS configuration: %w", err)
        }</span>

        <span class="cov0" title="0">dynamoClient := dynamodb.NewFromConfig(awsCfg)
        executionRepo := dynamorepo.NewExecutionRepository(dynamoClient, cfg.ExecutionsTable, log)

        log.Debug("event processor initialized", "executionsTable", cfg.ExecutionsTable)

        return &amp;Processor{
                executionRepo: executionRepo,
                logger:        log,
        }, nil</span>
}

// HandleEvent is the main entry point for Lambda event processing
// It routes events based on their detail-type
func (p *Processor) HandleEvent(ctx context.Context, event *events.CloudWatchEvent) error <span class="cov8" title="1">{
        reqLogger := logger.DeriveRequestLogger(ctx, p.logger)

        reqLogger.Debug("received event", "event", event)

        switch event.DetailType </span>{
        case "ECS Task State Change":<span class="cov0" title="0">
                return p.handleECSTaskCompletion(ctx, event)</span>
        default:<span class="cov8" title="1">
                reqLogger.Info("ignoring unhandled event type",
                        "detailType", event.DetailType,
                        "source", event.Source,
                )
                return nil</span>
        }
}

// HandleEventJSON is a helper for testing that accepts raw JSON
func (p *Processor) HandleEventJSON(ctx context.Context, eventJSON []byte) error <span class="cov8" title="1">{
        var event events.CloudWatchEvent
        if err := json.Unmarshal(eventJSON, &amp;event); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to unmarshal event: %w", err)
        }</span>
        <span class="cov8" title="1">return p.HandleEvent(ctx, &amp;event)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package events

import "time"

// ECSTaskStateChangeEvent represents the detail structure of an ECS Task State Change event
type ECSTaskStateChangeEvent struct {
        ClusterArn    string            `json:"clusterArn"`
        TaskArn       string            `json:"taskArn"`
        LastStatus    string            `json:"lastStatus"`
        DesiredStatus string            `json:"desiredStatus"`
        Containers    []ContainerDetail `json:"containers"`
        StartedAt     string            `json:"startedAt"`
        StoppedAt     string            `json:"stoppedAt"`
        StoppedReason string            `json:"stoppedReason"`
        StopCode      string            `json:"stopCode"`
        CPU           string            `json:"cpu"`
        Memory        string            `json:"memory"`
}

// ContainerDetail represents a container within an ECS task
type ContainerDetail struct {
        ContainerArn string `json:"containerArn"`
        Name         string `json:"name"`
        ExitCode     *int   `json:"exitCode,omitempty"`
        Reason       string `json:"reason,omitempty"`
}

// ParseTime parses an RFC3339 timestamp string
func ParseTime(timeStr string) (time.Time, error) <span class="cov8" title="1">{
        return time.Parse(time.RFC3339, timeStr)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package lambdaapi provides Lambda handler creation for AWS Lambda Function URLs,
// integrating the application service with the HTTP router through algnhsa adapter.
package lambdaapi

import (
        "runvoy/internal/app"
        "runvoy/internal/server"
        "time"

        "github.com/akrylysov/algnhsa"
        "github.com/aws/aws-lambda-go/lambda"
)

// NewHandler creates a new Lambda handler with the given service.
// The request timeout is passed to the router to configure the timeout middleware.
// It uses algnhsa to adapt the chi router to work with Lambda Function URLs.
func NewHandler(svc *app.Service, requestTimeout time.Duration) lambda.Handler <span class="cov0" title="0">{
        router := server.NewRouter(svc, requestTimeout)
        return algnhsa.New(router.Handler(), nil)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package logger provides structured logging utilities for runvoy.
// It includes context-aware logging and log level management.
package logger

import (
        "context"
        "log/slog"
        "time"

        "github.com/aws/aws-lambda-go/lambdacontext"
)

type contextKey string

const (
        requestIDContextKey contextKey = "requestID"
)

// WithRequestID returns a new context with the given request ID attached.
// This should be used by server middleware to add request IDs to the context.
func WithRequestID(ctx context.Context, requestID string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, requestIDContextKey, requestID)
}</span>

// GetRequestID extracts the request ID from the context.
// The request ID is set by server middleware when available.
func GetRequestID(ctx context.Context) string <span class="cov8" title="1">{
        if requestID, ok := ctx.Value(requestIDContextKey).(string); ok </span><span class="cov8" title="1">{
                return requestID
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// DeriveRequestLogger returns a logger enriched with request-scoped fields
// available in the provided context. Today it extracts AWS Lambda request ID
// when present. In the future, additional providers can be added here without
// changing call sites across the codebase.
func DeriveRequestLogger(ctx context.Context, base *slog.Logger) *slog.Logger <span class="cov8" title="1">{
        if base == nil </span><span class="cov8" title="1">{
                return slog.Default()
        }</span>

        // Try to get requestID from context value first (used in HTTP server)
        <span class="cov8" title="1">if requestID := GetRequestID(ctx); requestID != "" </span><span class="cov8" title="1">{
                return base.With("requestID", requestID)
        }</span>

        // Fall back to AWS Lambda request ID (used in Lambda functions)
        <span class="cov8" title="1">if lc, ok := lambdacontext.FromContext(ctx); ok </span><span class="cov8" title="1">{
                if lc.AwsRequestID != "" </span><span class="cov8" title="1">{
                        return base.With("requestID", lc.AwsRequestID)
                }</span>
        }

        <span class="cov8" title="1">return base</span>
}

// GetDeadlineInfo returns logging attributes for context deadline information.
// Returns the absolute deadline time and remaining duration if set, or "none" if no deadline.
func GetDeadlineInfo(ctx context.Context) []any <span class="cov8" title="1">{
        deadline, ok := ctx.Deadline()
        if !ok </span><span class="cov8" title="1">{
                return []any{"deadline", "none", "deadline_remaining", "none"}
        }</span>

        <span class="cov8" title="1">remaining := time.Until(deadline)
        return []any{
                "deadline", deadline.Format(time.RFC3339),
                "deadline_remaining", remaining.String(),
        }</span>
}

// SliceToMap converts a slice of alternating key-value pairs to a map[string]any.
// It expects the slice to have an even number of elements with string keys.
// Non-string keys are skipped.
func SliceToMap(args []any) map[string]any <span class="cov8" title="1">{
        argsMap := make(map[string]any)
        for i := 0; i &lt; len(args); i += 2 </span><span class="cov8" title="1">{
                if i+1 &lt; len(args) </span><span class="cov8" title="1">{
                        if key, ok := args[i].(string); ok </span><span class="cov8" title="1">{
                                argsMap[key] = args[i+1]
                        }</span>
                }
        }
        <span class="cov8" title="1">return argsMap</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package logger

import (
        "fmt"
        "log/slog"
        "os"
        "sort"
        "strings"

        "runvoy/internal/constants"

        "github.com/lmittmann/tint"
)

// flattenMapAttr flattens nested maps into a readable key=value format
// Example: map[deadline:none status:SUCCEEDED] becomes "deadline=none status=SUCCEEDED"
func flattenMapAttr(prefix string, value any) string <span class="cov8" title="1">{
        var parts []string

        switch v := value.(type) </span>{
        case map[string]any:<span class="cov8" title="1">
                keys := make([]string, 0, len(v))
                for k := range v </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)

                for _, key := range keys </span><span class="cov8" title="1">{
                        val := v[key]
                        fullKey := key
                        if prefix != "" </span><span class="cov8" title="1">{
                                fullKey = prefix + "." + key
                        }</span>

                        <span class="cov8" title="1">switch nested := val.(type) </span>{
                        case map[string]any:<span class="cov0" title="0">
                                parts = append(parts, flattenMapAttr(fullKey, nested))</span>
                        case map[string]string:<span class="cov8" title="1">
                                parts = append(parts, flattenMapAttr(fullKey, nested))</span>
                        default:<span class="cov8" title="1">
                                parts = append(parts, fmt.Sprintf("%s=%v", fullKey, val))</span>
                        }
                }
        case map[string]string:<span class="cov8" title="1">
                keys := make([]string, 0, len(v))
                for k := range v </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)

                for _, key := range keys </span><span class="cov8" title="1">{
                        fullKey := key
                        if prefix != "" </span><span class="cov8" title="1">{
                                fullKey = prefix + "." + key
                        }</span>
                        <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("%s=%v", fullKey, v[key]))</span>
                }
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", value)</span>
        }

        <span class="cov8" title="1">return strings.Join(parts, " ")</span>
}

// replaceAttrForDev transforms attributes for better readability in dev environment
func replaceAttrForDev(_ []string, a slog.Attr) slog.Attr <span class="cov8" title="1">{
        switch v := a.Value.Any().(type) </span>{
        case map[string]any, map[string]string:<span class="cov8" title="1">
                flattened := flattenMapAttr(a.Key, v)
                return slog.String(a.Key, flattened)</span>
        }
        <span class="cov8" title="1">return a</span>
}

// Initialize sets up the global slog logger based on the environment
func Initialize(env constants.Environment, level slog.Level) *slog.Logger <span class="cov8" title="1">{
        var handler slog.Handler

        if env == constants.Production </span><span class="cov8" title="1">{
                handler = slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{
                        Level: level,
                })
        }</span> else<span class="cov8" title="1"> {
                handler = tint.NewHandler(os.Stderr, &amp;tint.Options{
                        Level:       level,
                        ReplaceAttr: replaceAttrForDev,
                })
        }</span>

        <span class="cov8" title="1">logger := slog.New(handler)
        slog.SetDefault(logger)
        slog.Debug("logger initialized", "env", env, "level", level)

        return logger</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package output provides formatted terminal output utilities.
// It includes colors, spinners, progress bars, and other CLI display helpers.
package output

import (
        "fmt"
        "io"
        "os"
        "regexp"
        "strings"
        "time"
        "unicode/utf8"

        "runvoy/internal/constants"

        "github.com/fatih/color"
)

var (
        // Colors and styles
        green  = color.New(color.FgGreen)
        red    = color.New(color.FgRed)
        yellow = color.New(color.FgYellow)
        cyan   = color.New(color.FgCyan)
        gray   = color.New(color.FgHiBlack)
        bold   = color.New(color.Bold)

        // Stdout is the output writer for normal output (can be overridden for testing).
        Stdout io.Writer = os.Stdout
        // Stderr is the output writer for error output (can be overridden for testing).
        Stderr io.Writer = os.Stderr

        // Disable colors if not TTY or NO_COLOR is set
        noColor = func() bool <span class="cov8" title="1">{
                disable := os.Getenv("NO_COLOR") != "" || !isTerminal(os.Stdout)
                if disable </span><span class="cov8" title="1">{
                        color.NoColor = true
                }</span>
                <span class="cov8" title="1">return disable</span>
        }()
        // Matches ANSI escape sequences used for colors/styles
        ansiRegexp = regexp.MustCompile(`\x1b\[[0-9;]*m`)
)

// visibleWidth returns the number of visible characters, ignoring ANSI escape codes
func visibleWidth(s string) int <span class="cov8" title="1">{
        clean := ansiRegexp.ReplaceAllString(s, "")
        return utf8.RuneCountInString(clean)
}</span>

// Successf prints a success message with a checkmark
// Example: âœ“ Stack created successfully
func Successf(format string, a ...interface{}) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(Stdout, green.Sprint("âœ“")+" "+format+"\n", a...)
}</span>

// Infof prints an informational message with an arrow
// Example: â†’ Creating CloudFormation stack...
func Infof(format string, a ...interface{}) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(Stdout, cyan.Sprint("â†’")+" "+format+"\n", a...)
}</span>

// Warningf prints a warning message with a warning symbol
// Example: âš  Lock already held by alice@acme.com
func Warningf(format string, a ...interface{}) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(Stdout, yellow.Sprint("âš ")+" "+format+"\n", a...)
}</span>

// Errorf prints an error message with an X symbol
// Example: âœ— Failed to create stack: permission denied
func Errorf(format string, a ...interface{}) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(Stdout, red.Sprint("âœ—")+" "+format+"\n", a...)
}</span>

// Fatalf prints an error message and exits with code 1
func Fatalf(format string, a ...interface{}) <span class="cov0" title="0">{
        Errorf(format, a...)
        os.Exit(1)
}</span>

// Step prints a step in a multi-step process
// Example: [1/3] Waiting for stack creation
func Step(step, total int, message string) <span class="cov8" title="1">{
        _, _ = gray.Fprintf(Stdout, "[%d/%d] ", step, total)
        _, _ = fmt.Fprintln(Stdout, message)
}</span>

// StepSuccess prints a successful step completion
// Example: [1/3] âœ“ Stack created
func StepSuccess(step, total int, message string) <span class="cov0" title="0">{
        _, _ = gray.Fprintf(Stdout, "[%d/%d] ", step, total)
        _, _ = fmt.Fprintf(Stdout, "%s %s\n", green.Sprint("âœ“"), message)
}</span>

// StepError prints a failed step
// Example: [2/3] âœ— Failed to generate API key
func StepError(step, total int, message string) <span class="cov0" title="0">{
        _, _ = gray.Fprintf(Stdout, "[%d/%d] ", step, total)
        _, _ = fmt.Fprintf(Stdout, "%s %s\n", red.Sprint("âœ—"), message)
}</span>

// Header prints a section header with a separator line
// Example:
// ðŸš€ Initializing runvoy infrastructure
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
func Header(text string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintln(Stdout)
        _, _ = fmt.Fprintln(Stdout, bold.Sprint(text))
        _, _ = fmt.Fprintln(Stdout, gray.Sprint(strings.Repeat("â”", constants.HeaderSeparatorLength)))
}</span>

// Subheader prints a smaller section header
// Example:
// Configuration Details
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
func Subheader(text string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintln(Stdout)
        _, _ = fmt.Fprintln(Stdout, cyan.Sprint(text))
        _, _ = fmt.Fprintln(Stdout, gray.Sprint(strings.Repeat("â”€", len(text))))
}</span>

// KeyValue prints a key-value pair with indentation
// Example:   Stack name: runvoy
func KeyValue(key, value string) <span class="cov8" title="1">{
        _, _ = fmt.Fprintf(Stdout, "  %s: %s\n", gray.Sprint(key), value)
}</span>

// KeyValueBold prints a key-value pair with bold value
// Example:   API Key: sk_live_abc123...
func KeyValueBold(key, value string) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(Stdout, "  %s: %s\n", gray.Sprint(key), bold.Sprint(value))
}</span>

// Blank prints a blank line
func Blank() <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(Stdout)
}</span>

// Println prints a plain line without any formatting
func Println(a ...interface{}) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(Stdout, a...)
}</span>

// Printf prints a formatted plain line
func Printf(format string, a ...interface{}) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(Stdout, format, a...)
}</span>

// Bold prints text in bold
func Bold(text string) string <span class="cov8" title="1">{
        return bold.Sprint(text)
}</span>

// Cyan prints text in cyan
func Cyan(text string) string <span class="cov8" title="1">{
        return cyan.Sprint(text)
}</span>

// Gray prints text in gray
func Gray(text string) string <span class="cov8" title="1">{
        return gray.Sprint(text)
}</span>

// Green prints text in green
func Green(text string) string <span class="cov8" title="1">{
        return green.Sprint(text)
}</span>

// Red prints text in red
func Red(text string) string <span class="cov8" title="1">{
        return red.Sprint(text)
}</span>

// Yellow prints text in yellow
func Yellow(text string) string <span class="cov8" title="1">{
        return yellow.Sprint(text)
}</span>

// Box prints text in a rounded box
// Example:
// â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
// â”‚  Configuration saved!       â”‚
// â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
func Box(text string) <span class="cov8" title="1">{
        lines := strings.Split(text, "\n")
        maxLen := 0
        for _, line := range lines </span><span class="cov8" title="1">{
                if len(line) &gt; maxLen </span><span class="cov8" title="1">{
                        maxLen = len(line)
                }</span>
        }

        // Top border
        <span class="cov8" title="1">_, _ = fmt.Fprintln(Stdout, gray.Sprint("â•­â”€"+strings.Repeat("â”€", maxLen+constants.BoxBorderPadding)+"â”€â•®"))

        // Content
        for _, line := range lines </span><span class="cov8" title="1">{
                padding := strings.Repeat(" ", maxLen-len(line))
                _, _ = fmt.Fprintf(Stdout, "%s  %s%s  %s\n",
                        gray.Sprint("â”‚"),
                        line,
                        padding,
                        gray.Sprint("â”‚"))
        }</span>

        // Bottom border
        <span class="cov8" title="1">_, _ = fmt.Fprintln(Stdout, gray.Sprint("â•°â”€"+strings.Repeat("â”€", maxLen+constants.BoxBorderPadding)+"â”€â•¯"))</span>
}

// Table prints a simple table with headers
// Example:
// Execution ID    Status      Duration
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”€
// exec_abc123     completed   10m 35s
// exec_def456     running     2m 15s
func Table(headers []string, rows [][]string) <span class="cov8" title="1">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate column widths
        <span class="cov8" title="1">widths := make([]int, len(headers))
        for i, h := range headers </span><span class="cov8" title="1">{
                widths[i] = visibleWidth(h)
        }</span>
        <span class="cov8" title="1">for _, row := range rows </span><span class="cov8" title="1">{
                for i, cell := range row </span><span class="cov8" title="1">{
                        if i &lt; len(widths) </span><span class="cov8" title="1">{
                                w := visibleWidth(cell)
                                if w &gt; widths[i] </span><span class="cov8" title="1">{
                                        widths[i] = w
                                }</span>
                        }
                }
        }

        // Print headers
        <span class="cov8" title="1">for i, h := range headers </span><span class="cov8" title="1">{
                header := bold.Sprint(h)
                pad := widths[i] - visibleWidth(h)
                if pad &lt; 0 </span><span class="cov0" title="0">{
                        pad = 0
                }</span>
                <span class="cov8" title="1">_, _ = fmt.Fprint(Stdout, header)
                _, _ = fmt.Fprint(Stdout, strings.Repeat(" ", pad))
                _, _ = fmt.Fprint(Stdout, "  ")</span>
        }
        <span class="cov8" title="1">_, _ = fmt.Fprintln(Stdout)

        // Print separator
        for i := range headers </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(Stdout, "%s  ", gray.Sprint(strings.Repeat("â”€", widths[i])))
        }</span>
        <span class="cov8" title="1">_, _ = fmt.Fprintln(Stdout)

        // Print rows
        for _, row := range rows </span><span class="cov8" title="1">{
                for i, cell := range row </span><span class="cov8" title="1">{
                        if i &gt;= len(widths) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">pad := widths[i] - visibleWidth(cell)
                        if pad &lt; 0 </span><span class="cov0" title="0">{
                                pad = 0
                        }</span>
                        <span class="cov8" title="1">_, _ = fmt.Fprint(Stdout, cell)
                        _, _ = fmt.Fprint(Stdout, strings.Repeat(" ", pad))
                        _, _ = fmt.Fprint(Stdout, "  ")</span>
                }
                <span class="cov8" title="1">_, _ = fmt.Fprintln(Stdout)</span>
        }
}

// List prints a bulleted list
// Example:
//   - Item one
//   - Item two
//   - Item three
func List(items []string) <span class="cov8" title="1">{
        for _, item := range items </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(Stdout, "  %s %s\n", cyan.Sprint("â€¢"), item)
        }</span>
}

// NumberedList prints a numbered list
// Example:
//  1. First step
//  2. Second step
//  3. Third step
func NumberedList(items []string) <span class="cov8" title="1">{
        for i, item := range items </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(Stdout, "  %s %s\n", gray.Sprintf("%d.", i+1), item)
        }</span>
}

// Spinner represents a simple text spinner for long operations
type Spinner struct {
        message string
        frames  []string
        frame   int
        done    chan bool
        running bool
}

// NewSpinner creates a new spinner with the given message
func NewSpinner(message string) *Spinner <span class="cov8" title="1">{
        return &amp;Spinner{
                message: message,
                frames:  []string{"â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "},
                done:    make(chan bool),
        }
}</span>

// Start starts the spinner animation
func (s *Spinner) Start() <span class="cov8" title="1">{
        if noColor || !isTerminal(os.Stdout) </span><span class="cov8" title="1">{
                // If not a TTY, just print the message once
                Infof(s.message)
                return
        }</span>

        <span class="cov0" title="0">s.running = true
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(constants.SpinnerTickerInterval)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.done:<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                frame := s.frames[s.frame%len(s.frames)]
                                _, _ = fmt.Fprintf(Stdout, "\r%s %s", cyan.Sprint(frame), s.message)
                                s.frame++</span>
                        }
                }
        }()
}

// Stop stops the spinner and clears the line
func (s *Spinner) Stop() <span class="cov8" title="1">{
        if !s.running </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">s.done &lt;- true
        _, _ = fmt.Fprint(Stdout, "\r"+strings.Repeat(" ", len(s.message)+10)+"\r")</span> //nolint:mnd
}

// Success stops the spinner and prints a success message
func (s *Spinner) Success(message string) <span class="cov0" title="0">{
        s.Stop()
        Successf(message)
}</span>

// Error stops the spinner and prints an error message
func (s *Spinner) Error(message string) <span class="cov0" title="0">{
        s.Stop()
        Errorf(message)
}</span>

// ProgressBar represents a simple text progress bar
type ProgressBar struct {
        total   int
        current int
        width   int
        message string
}

// NewProgressBar creates a new progress bar
func NewProgressBar(total int, message string) *ProgressBar <span class="cov8" title="1">{
        return &amp;ProgressBar{
                total:   total,
                current: 0,
                width:   constants.ProgressBarWidth,
                message: message,
        }
}</span>

// Update updates the progress bar to the given value
func (p *ProgressBar) Update(current int) <span class="cov8" title="1">{
        if noColor || !isTerminal(os.Stdout) </span><span class="cov8" title="1">{
                // Simple percentage output for non-TTY
                if current%10 == 0 || current == p.total </span><span class="cov8" title="1">{
                        _, _ = fmt.Fprintf(Stdout, "\r%s... %d%%", p.message, (current*constants.PercentageMultiplier)/p.total)
                }</span>
                <span class="cov8" title="1">if current == p.total </span><span class="cov8" title="1">{
                        _, _ = fmt.Fprintln(Stdout)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov0" title="0">p.current = current
        percent := float64(current) / float64(p.total)
        filled := int(percent * float64(p.width))

        bar := strings.Repeat("â–ˆ", filled) + strings.Repeat("â–‘", p.width-filled)

        _, _ = fmt.Fprintf(Stdout, "\r%s %s %3.0f%%",
                p.message,
                cyan.Sprint(bar),
                percent*constants.PercentageMultiplier)

        if current == p.total </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(Stdout)
        }</span>
}

// Increment increments the progress bar by 1
func (p *ProgressBar) Increment() <span class="cov0" title="0">{
        p.Update(p.current + 1)
}</span>

// Complete marks the progress bar as complete
func (p *ProgressBar) Complete() <span class="cov8" title="1">{
        p.Update(p.total)
}</span>

// Confirm prompts the user for yes/no confirmation
// Returns true if user confirms (y/Y), false otherwise
func Confirm(prompt string) bool <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(Stdout, "%s [y/N]: ", yellow.Sprint("?")+" "+prompt)

        var response string
        _, _ = fmt.Scanln(&amp;response)

        response = strings.ToLower(strings.TrimSpace(response))
        return response == "y" || response == "yes"
}</span>

// Prompt prompts the user for input
func Prompt(prompt string) string <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(Stdout, "%s: ", cyan.Sprint("?")+" "+prompt)

        var response string
        _, _ = fmt.Scanln(&amp;response)

        return strings.TrimSpace(response)
}</span>

// PromptRequired prompts the user for input and requires a non-empty response
func PromptRequired(prompt string) string <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                response := Prompt(prompt)
                if response != "" </span><span class="cov0" title="0">{
                        return response
                }</span>
                <span class="cov0" title="0">Warningf("This field is required")</span>
        }
}

// PromptSecret prompts for sensitive input (like passwords)
// Note: This is a simple implementation. For production, consider using
// golang.org/x/term for proper terminal handling
func PromptSecret(prompt string) string <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(Stdout, "%s: ", cyan.Sprint("?")+" "+prompt)

        var response string
        _, _ = fmt.Scanln(&amp;response)

        return strings.TrimSpace(response)
}</span>

// StatusBadge prints a colored status badge
func StatusBadge(status string) string <span class="cov8" title="1">{
        switch strings.ToLower(status) </span>{
        case "completed", "success", "succeeded":<span class="cov8" title="1">
                return green.Sprint("â— " + status)</span>
        case "running", "in_progress", "starting":<span class="cov8" title="1">
                return yellow.Sprint("â— " + status)</span>
        case "failed", "error":<span class="cov8" title="1">
                return red.Sprint("â— " + status)</span>
        case "pending", "queued":<span class="cov8" title="1">
                return gray.Sprint("â— " + status)</span>
        default:<span class="cov0" title="0">
                return cyan.Sprint("â— " + status)</span>
        }
}

// Duration formats a duration in a human-readable way
func Duration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt; time.Minute </span><span class="cov8" title="1">{
                return fmt.Sprintf("%.0fs", d.Seconds())
        }</span>
        <span class="cov8" title="1">if d &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(d.Minutes())
                seconds := int(d.Seconds()) % constants.SecondsPerMinute
                return fmt.Sprintf("%dm %ds", minutes, seconds)
        }</span>
        <span class="cov8" title="1">hours := int(d.Hours())
        minutes := int(d.Minutes()) % constants.MinutesPerHour
        return fmt.Sprintf("%dh %dm", hours, minutes)</span>
}

// Bytes formats bytes in a human-readable way
func Bytes(b int64) string <span class="cov8" title="1">{
        const unit = 1024
        if b &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", b)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := b / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])</span>
}

// isTerminal checks if the writer is a terminal
func isTerminal(w io.Writer) bool <span class="cov8" title="1">{
        if f, ok := w.(*os.File); ok </span><span class="cov8" title="1">{
                fileInfo, _ := f.Stat()
                return (fileInfo.Mode() &amp; os.ModeCharDevice) != 0
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package server implements the HTTP server and handlers for runvoy.
// It provides REST API endpoints for user management and command execution.
package server

import (
        "encoding/json"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "runvoy/internal/api"
        "runvoy/internal/constants"
        apperrors "runvoy/internal/errors"

        "github.com/go-chi/chi/v5"
)

// handleCreateUser handles POST /api/v1/users to create a new user with an API key
func (r *Router) handleCreateUser(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())
        var createReq api.CreateUserRequest

        if err := json.NewDecoder(req.Body).Decode(&amp;createReq); err != nil </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())

                return
        }</span>

        // Extract admin user from context
        <span class="cov0" title="0">user, ok := req.Context().Value(userContextKey).(*api.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                writeErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "user not found in context")
                return
        }</span>

        <span class="cov0" title="0">resp, err := r.svc.CreateUser(req.Context(), createReq, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to create user", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to create user", errorMsg)

                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)
        _ = json.NewEncoder(w).Encode(resp)</span>
}

// handleRevokeUser handles POST /api/v1/users/revoke to revoke a user's API key
func (r *Router) handleRevokeUser(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())
        var revokeReq api.RevokeUserRequest

        if err := json.NewDecoder(req.Body).Decode(&amp;revokeReq); err != nil </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "Invalid request body", err.Error())

                return
        }</span>

        <span class="cov8" title="1">if err := r.svc.RevokeUser(req.Context(), revokeReq.Email); err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to revoke user", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to revoke user", errorMsg)

                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(api.RevokeUserResponse{
                Message: "user API key revoked successfully",
                Email:   revokeReq.Email,
        })</span>
}

// handleListUsers handles GET /api/v1/users to list all users
func (r *Router) handleListUsers(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        resp, err := r.svc.ListUsers(req.Context())
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to list users", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to list users", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(resp)</span>
}

// handleRunCommand handles POST /api/v1/run to execute a command in an ephemeral container
func (r *Router) handleRunCommand(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        user, ok := req.Context().Value(userContextKey).(*api.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                writeErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "user not found in context")
                return
        }</span>

        <span class="cov8" title="1">var execReq api.ExecutionRequest
        if err := json.NewDecoder(req.Body).Decode(&amp;execReq); err != nil </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := r.svc.RunCommand(req.Context(), user.Email, &amp;execReq)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Error("failed to run command", "context", map[string]string{
                        "error":      err.Error(),
                        "statusCode": strconv.Itoa(statusCode),
                        "errorCode":  errorCode,
                })

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to run command", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusAccepted)
        _ = json.NewEncoder(w).Encode(resp)</span>
}

// handleGetExecutionLogs handles GET /api/v1/executions/{executionID}/logs to fetch logs for an execution
func (r *Router) handleGetExecutionLogs(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        executionID := strings.TrimSpace(chi.URLParam(req, "executionID"))
        if executionID == "" </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid execution id", "executionID is required")
                return
        }</span>

        <span class="cov8" title="1">resp, err := r.svc.GetLogsByExecutionID(req.Context(), executionID)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to get execution logs", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to get execution logs", errorMsg)

                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(resp)</span>
}

// handleGetExecutionStatus handles GET /api/v1/executions/{executionID}/status to fetch execution status
func (r *Router) handleGetExecutionStatus(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        executionID := strings.TrimSpace(chi.URLParam(req, "executionID"))
        if executionID == "" </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid execution id", "executionID is required")
                return
        }</span>

        <span class="cov8" title="1">resp, err := r.svc.GetExecutionStatus(req.Context(), executionID)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to get execution status",
                        "executionID", executionID,
                        "error", err,
                        "statusCode", statusCode,
                        "errorCode", errorCode)

                writeErrorResponseWithCode(
                        w, statusCode, errorCode,
                        "failed to get execution status for executionID "+executionID,
                        errorMsg,
                )
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(resp)</span>
}

// handleKillExecution handles POST /api/v1/executions/{executionID}/kill to terminate a running execution
func (r *Router) handleKillExecution(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        executionID := strings.TrimSpace(chi.URLParam(req, "executionID"))
        if executionID == "" </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid execution id", "executionID is required")
                return
        }</span>

        <span class="cov8" title="1">err := r.svc.KillExecution(req.Context(), executionID)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to kill execution",
                        "executionID", executionID,
                        "error", err,
                        "statusCode", statusCode,
                        "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to kill execution", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(api.KillExecutionResponse{
                ExecutionID: executionID,
                Message:     "Execution termination initiated",
        })</span>
}

// handleListExecutions handles GET /api/v1/executions to list all executions
func (r *Router) handleListExecutions(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        executions, err := r.svc.ListExecutions(req.Context())
        if err != nil </span><span class="cov8" title="1">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to list executions", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to list executions", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(executions)</span>
}

// handleHealth returns a simple health check response
func (r *Router) handleHealth(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(api.HealthResponse{
                Status:  "ok",
                Version: *constants.GetVersion(),
        })
}</span>

// handleClaimAPIKey handles GET /claim/{token} to claim a pending API key
func (r *Router) handleClaimAPIKey(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        logger := r.GetLoggerFromContext(req.Context())

        // Extract token from URL path
        secretToken := strings.TrimSpace(chi.URLParam(req, "token"))
        if secretToken == "" </span><span class="cov0" title="0">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid token", "token is required")
                return
        }</span>

        // Get client IP address
        <span class="cov0" title="0">ipAddress := getClientIP(req)

        // Claim the API key
        claimResp, err := r.svc.ClaimAPIKey(req.Context(), secretToken, ipAddress)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to claim API key", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to claim API key", errorMsg)
                return
        }</span>

        // Return JSON response
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(claimResp)</span>
}

// handleRegisterImage handles POST /api/v1/images/register to register a new Docker image
func (r *Router) handleRegisterImage(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())
        var registerReq api.RegisterImageRequest

        if err := json.NewDecoder(req.Body).Decode(&amp;registerReq); err != nil </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid request body", err.Error())
                return
        }</span>

        <span class="cov8" title="1">resp, err := r.svc.RegisterImage(req.Context(), registerReq.Image, registerReq.IsDefault)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to register image", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to register image", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        _ = json.NewEncoder(w).Encode(resp)</span>
}

// handleListImages handles GET /api/v1/images to list all registered Docker images
func (r *Router) handleListImages(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        resp, err := r.svc.ListImages(req.Context())
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to list images", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to list images", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(resp)</span>
}

// handleRemoveImage handles DELETE /api/v1/images/{image} to remove a registered Docker image
// The image parameter may contain slashes and colons (e.g.,
// "ecr-public.us-east-1.amazonaws.com/docker/library/ubuntu:22.04")
// Uses catch-all route (*) to match paths with slashes
func (r *Router) handleRemoveImage(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger := r.GetLoggerFromContext(req.Context())

        imagePath := strings.TrimPrefix(strings.TrimSpace(chi.URLParam(req, "*")), "/")

        if imagePath == "" </span><span class="cov8" title="1">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid image", "image parameter is required")
                return
        }</span>

        <span class="cov8" title="1">image, decodeErr := url.PathUnescape(imagePath)
        if decodeErr != nil </span><span class="cov0" title="0">{
                image = imagePath
        }</span>
        <span class="cov8" title="1">image = strings.TrimSpace(image)
        if image == "" </span><span class="cov0" title="0">{
                writeErrorResponse(w, http.StatusBadRequest, "invalid image", "image parameter is required")
                return
        }</span>

        <span class="cov8" title="1">err := r.svc.RemoveImage(req.Context(), image)
        if err != nil </span><span class="cov0" title="0">{
                statusCode := apperrors.GetStatusCode(err)
                errorCode := apperrors.GetErrorCode(err)
                errorMsg := apperrors.GetErrorMessage(err)

                logger.Debug("failed to remove image", "error", err, "statusCode", statusCode, "errorCode", errorCode)

                writeErrorResponseWithCode(w, statusCode, errorCode, "failed to remove image", errorMsg)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(api.RemoveImageResponse{
                Image:   image,
                Message: "Image removed successfully",
        })</span>
}

// getClientIP extracts the client IP address from request headers
func getClientIP(req *http.Request) string <span class="cov8" title="1">{
        // Check X-Forwarded-For header (used by proxies/load balancers)
        xff := req.Header.Get("X-Forwarded-For")
        if xff != "" </span><span class="cov8" title="1">{
                // X-Forwarded-For can contain multiple IPs, take the first one
                ips := strings.Split(xff, ",")
                return strings.TrimSpace(ips[0])
        }</span>

        // Check X-Real-IP header (alternative proxy header)
        <span class="cov8" title="1">xRealIP := req.Header.Get("X-Real-IP")
        if xRealIP != "" </span><span class="cov8" title="1">{
                return strings.TrimSpace(xRealIP)
        }</span>

        // Fall back to RemoteAddr, stripping the port if present
        <span class="cov8" title="1">ip := req.RemoteAddr
        if colonIndex := strings.LastIndex(ip, ":"); colonIndex != -1 </span><span class="cov8" title="1">{
                ip = ip[:colonIndex]
        }</span>
        <span class="cov8" title="1">return ip</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package server

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "log/slog"
        "net/http"
        "sync"
        "time"

        "runvoy/internal/api"
        "runvoy/internal/constants"
        apperrors "runvoy/internal/errors"
        loggerPkg "runvoy/internal/logger"

        "github.com/aws/aws-lambda-go/lambdacontext"
)

const (
        loggerContextKey      contextKey = "logger"
        lastUsedUpdateTimeout            = 5 * time.Second
)

// generateRequestID generates a random request ID using crypto/rand
func generateRequestID() string <span class="cov8" title="1">{
        b := make([]byte, constants.RequestIDByteSize)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return hex.EncodeToString([]byte(time.Now().String()))
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(b)</span>
}

// requestIDMiddleware extracts the request ID from the context (if present) or generates a random one.
// Priority: 1) Existing request ID in context, 2) Lambda request ID, 3) Generated random ID.
func (r *Router) requestIDMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                requestID := loggerPkg.GetRequestID(req.Context())

                if requestID == "" </span><span class="cov8" title="1">{
                        if lc, ok := lambdacontext.FromContext(req.Context()); ok &amp;&amp; lc.AwsRequestID != "" </span><span class="cov8" title="1">{
                                requestID = lc.AwsRequestID
                        }</span>
                }

                <span class="cov8" title="1">if requestID == "" </span><span class="cov8" title="1">{
                        requestID = generateRequestID()
                }</span>

                <span class="cov8" title="1">ctx := loggerPkg.WithRequestID(req.Context(), requestID)
                log := r.svc.Logger.With("requestID", requestID)
                ctx = context.WithValue(ctx, loggerContextKey, log)

                next.ServeHTTP(w, req.WithContext(ctx))</span>
        })
}

// requestTimeoutMiddleware creates a context with timeout for each request.
// The timeout starts when the request is received, ensuring each request has
// a fair timeout regardless of connection reuse.
func (r *Router) requestTimeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                        ctx, cancel := context.WithTimeout(req.Context(), timeout)
                        defer cancel()

                        req = req.WithContext(ctx)

                        next.ServeHTTP(w, req)

                        if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                                logger := r.GetLoggerFromContext(req.Context())
                                logger.Warn("request timeout exceeded", "request", map[string]interface{}{
                                        "method":  req.Method,
                                        "path":    req.URL.Path,
                                        "timeout": timeout,
                                })

                                // Note: Response may have already been written by handler
                                // The context cancellation will have already propagated to
                                // any operations (like DynamoDB calls) that were using the context
                        }</span>
                })
        }
}

// corsMiddleware handles CORS headers for cross-origin requests
func corsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                origin := req.Header.Get("Origin")
                if origin != "" </span><span class="cov0" title="0">{
                        w.Header().Set("Access-Control-Allow-Origin", origin)
                }</span> else<span class="cov8" title="1"> {
                        // If no Origin header, allow all origins (fallback)
                        w.Header().Set("Access-Control-Allow-Origin", "*")
                }</span>
                <span class="cov8" title="1">w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, X-API-Key")
                w.Header().Set("Access-Control-Max-Age", "3600")

                // Handle preflight requests
                if req.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, req)</span>
        })
}

// setContentTypeJSONMiddleware sets Content-Type to application/json for all responses
func setContentTypeJSONMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set(constants.ContentTypeHeader, "application/json")
                next.ServeHTTP(w, req)
        }</span>)
}

// handleAuthError handles authentication errors and writes appropriate responses.
func handleAuthError(w http.ResponseWriter, err error) <span class="cov8" title="1">{
        statusCode := apperrors.GetStatusCode(err)
        errorCode := apperrors.GetErrorCode(err)
        errorMsg := apperrors.GetErrorMessage(err)

        if statusCode &lt; 400 || statusCode &gt;= 600 </span><span class="cov0" title="0">{
                statusCode = http.StatusUnauthorized
        }</span>

        <span class="cov8" title="1">messagePrefix := "Unauthorized"
        if statusCode &gt;= constants.HTTPStatusServerError </span><span class="cov8" title="1">{
                messagePrefix = "Server error"
        }</span>

        <span class="cov8" title="1">writeErrorResponseWithCode(w, statusCode, errorCode, messagePrefix, errorMsg)</span>
}

// updateLastUsedAsync updates the user's last_used timestamp asynchronously.
func (r *Router) updateLastUsedAsync(user *api.User, requestID string, logger *slog.Logger) *sync.WaitGroup <span class="cov8" title="1">{
        var wg sync.WaitGroup
        wg.Add(1)
        go func(email string, reqID string) </span><span class="cov8" title="1">{
                defer wg.Done()
                ctx, cancel := context.WithTimeout(context.Background(), lastUsedUpdateTimeout)
                defer cancel()
                ctx = loggerPkg.WithRequestID(ctx, reqID)

                logger.Debug("updating user's last_used timestamp (async)", "user", map[string]any{
                        "email":              email,
                        "previous_last_used": user.LastUsed.Format(time.RFC3339),
                })

                newLastUsed, err := r.svc.UpdateUserLastUsed(ctx, email)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to update user's last_used timestamp", "error", map[string]any{
                                "error": err,
                                "user": map[string]any{
                                        "email": email,
                                },
                        })
                }</span> else<span class="cov8" title="1"> {
                        logger.Debug("user's last_used timestamp updated successfully", "user", map[string]any{
                                "email":              email,
                                "last_used":          newLastUsed.Format(time.RFC3339),
                                "previous_last_used": user.LastUsed.Format(time.RFC3339),
                        })
                }</span>
        }(user.Email, requestID)
        <span class="cov8" title="1">return &amp;wg</span>
}

// authenticateRequestMiddleware authenticates requests
// Adds authenticated user to request context
// Updates user's last_used timestamp asynchronously after successful authentication
func (r *Router) authenticateRequestMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                logger := r.GetLoggerFromContext(req.Context())
                apiKey := req.Header.Get(constants.APIKeyHeader)
                logger.Debug("authenticating request")

                if apiKey == "" </span><span class="cov8" title="1">{
                        writeErrorResponse(w, http.StatusUnauthorized, "Unauthorized", "API key is required")
                        return
                }</span>

                <span class="cov8" title="1">user, err := r.svc.AuthenticateUser(req.Context(), apiKey)
                if err != nil </span><span class="cov8" title="1">{
                        handleAuthError(w, err)
                        return
                }</span>

                <span class="cov8" title="1">logger.Info("user authenticated successfully", "email", user.Email)

                requestID := loggerPkg.GetRequestID(req.Context())
                wg := r.updateLastUsedAsync(user, requestID, logger)

                ctx := context.WithValue(req.Context(), userContextKey, user)
                next.ServeHTTP(w, req.WithContext(ctx))

                wg.Wait()</span>
        })
}

// requestLoggingMiddleware logs incoming requests and their responses
// Uses logger from context (includes request ID if available)
func (r *Router) requestLoggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                logger := r.GetLoggerFromContext(req.Context())
                start := time.Now()
                deadlineString := ""
                if deadline, ok := req.Context().Deadline(); ok </span><span class="cov8" title="1">{
                        deadlineString = deadline.Format(time.RFC3339)
                }</span>

                // Wrap the response writer to capture status code
                <span class="cov8" title="1">wrapped := &amp;responseWriter{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK, // default status code
                }

                logger.Info("processing incoming client request", "request", map[string]string{
                        "method":     req.Method,
                        "path":       req.URL.Path,
                        "remoteAddr": req.RemoteAddr,
                        "deadline":   deadlineString,
                })

                next.ServeHTTP(wrapped, req)
                duration := time.Since(start)

                logger.Info("sent response to client", "response", map[string]interface{}{
                        "status":   wrapped.statusCode,
                        "duration": duration.String(),
                })</span>
        })
}

// GetLoggerFromContext extracts the logger from request context
// Returns the request-scoped logger (with request ID if available) or falls back to service logger
func (r *Router) GetLoggerFromContext(ctx context.Context) *slog.Logger <span class="cov8" title="1">{
        if logger, ok := ctx.Value(loggerContextKey).(*slog.Logger); ok &amp;&amp; logger != nil </span><span class="cov8" title="1">{
                return logger
        }</span>

        <span class="cov0" title="0">return r.svc.Logger</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package server

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "runvoy/internal/api"
        "runvoy/internal/app"

        "github.com/go-chi/chi/v5"
)

// Router wraps a chi router with service dependencies for handling API requests.
type Router struct {
        router *chi.Mux
        svc    *app.Service
}

type contextKey string

const (
        userContextKey    contextKey = "user"
        serviceContextKey contextKey = "service"
)

// NewRouter creates a new chi router with routes configured.
// If requestTimeout is &gt; 0, adds a per-request timeout middleware.
// If requestTimeout is 0, no timeout middleware is added, allowing the
// environment (e.g., Lambda with its own timeout) to handle timeouts.
func NewRouter(svc *app.Service, requestTimeout time.Duration) *Router <span class="cov8" title="1">{
        r := chi.NewRouter()
        router := &amp;Router{
                router: r,
                svc:    svc,
        }

        if requestTimeout &gt; 0 </span><span class="cov8" title="1">{
                r.Use(router.requestTimeoutMiddleware(requestTimeout))
        }</span>
        <span class="cov8" title="1">r.Use(corsMiddleware)
        r.Use(setContentTypeJSONMiddleware)
        r.Use(router.requestIDMiddleware)
        r.Use(router.requestLoggingMiddleware)

        r.Route("/api/v1", func(r chi.Router) </span><span class="cov8" title="1">{
                // public routes
                r.Get("/claim/{token}", router.handleClaimAPIKey)
                r.Get("/health", router.handleHealth)

                // authenticated routes
                r.With(router.authenticateRequestMiddleware).Route("/users", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Get("/", router.handleListUsers)
                        r.Post("/create", router.handleCreateUser)
                        r.Post("/revoke", router.handleRevokeUser)
                }</span>)
                <span class="cov8" title="1">r.With(router.authenticateRequestMiddleware).Route("/images", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/register", router.handleRegisterImage)
                        r.Get("/", router.handleListImages)
                        r.Delete("/*", router.handleRemoveImage)
                }</span>)
                <span class="cov8" title="1">r.With(router.authenticateRequestMiddleware).Post("/run", router.handleRunCommand)
                r.With(router.authenticateRequestMiddleware).Get("/executions", router.handleListExecutions)
                r.With(router.authenticateRequestMiddleware).Get("/executions/{executionID}/logs",
                        router.handleGetExecutionLogs)
                r.With(router.authenticateRequestMiddleware).Get("/executions/{executionID}/status",
                        router.handleGetExecutionStatus)
                r.With(router.authenticateRequestMiddleware).Post("/executions/{executionID}/kill",
                        router.handleKillExecution)</span>
        })

        <span class="cov8" title="1">return router</span>
}

// responseWriter is a wrapper around http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        written    bool
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        if !rw.written </span><span class="cov8" title="1">{
                rw.statusCode = code
                rw.written = true
                rw.ResponseWriter.WriteHeader(code)
        }</span>
}

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if !rw.written </span><span class="cov8" title="1">{
                rw.statusCode = http.StatusOK
                rw.written = true
        }</span>

        <span class="cov8" title="1">return rw.ResponseWriter.Write(b)</span>
}

// ServeHTTP implements http.Handler for use with chi router
func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        r.router.ServeHTTP(w, req)
}</span>

// ChiMux returns the underlying chi router for advanced usage
func (r *Router) ChiMux() *chi.Mux <span class="cov0" title="0">{
        return r.router
}</span>

// Handler returns an http.Handler for the router
func (r *Router) Handler() http.Handler <span class="cov0" title="0">{
        return r.router
}</span>

// WithContext adds the service to the request context
func (r *Router) WithContext(ctx context.Context, svc *app.Service) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, serviceContextKey, svc)
}</span>

// writeErrorResponse is a helper to write consistent error responses
func writeErrorResponse(w http.ResponseWriter, statusCode int, message, details string) <span class="cov8" title="1">{
        w.WriteHeader(statusCode)
        _ = json.NewEncoder(w).Encode(api.ErrorResponse{
                Error:   message,
                Details: details,
        })
}</span>

// writeErrorResponseWithCode is a helper to write error responses with error codes
func writeErrorResponseWithCode(w http.ResponseWriter, statusCode int, code, message, details string) <span class="cov8" title="1">{
        w.WriteHeader(statusCode)
        resp := api.ErrorResponse{
                Error:   message,
                Details: details,
        }
        if code != "" </span><span class="cov8" title="1">{
                resp.Code = code
        }</span>
        <span class="cov8" title="1">_ = json.NewEncoder(w).Encode(resp)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package testutil

import (
        stderrors "errors"
        "testing"

        apperrors "runvoy/internal/errors"

        "github.com/stretchr/testify/assert"
)

// AssertErrorType checks if the error is of a specific type using errors.Is.
func AssertErrorType(t *testing.T, err, target error, _ ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        if !stderrors.Is(err, target) </span><span class="cov0" title="0">{
                return assert.Fail(t, "Error type mismatch", "Expected error type %T, got %T", target, err)
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AssertAppErrorCode checks if the error has a specific error code.
func AssertAppErrorCode(t *testing.T, err error, expectedCode string, _ ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        code := apperrors.GetErrorCode(err)
        if code != expectedCode </span><span class="cov0" title="0">{
                return assert.Fail(t, "Error code mismatch", "Expected error code %q, got %q", expectedCode, code)
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AssertAppErrorStatus checks if the error has a specific HTTP status code.
func AssertAppErrorStatus(t *testing.T, err error, expectedStatus int, _ ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        status := apperrors.GetStatusCode(err)
        if status != expectedStatus </span><span class="cov0" title="0">{
                return assert.Fail(t, "Status code mismatch", "Expected status %d, got %d", expectedStatus, status)
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AssertNoError is a wrapper around assert.NoError with context.
func AssertNoError(t *testing.T, err error, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        return assert.NoError(t, err, msgAndArgs...)
}</span>

// AssertError is a wrapper around assert.Error with context.
func AssertError(t *testing.T, err error, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        return assert.Error(t, err, msgAndArgs...)
}</span>

// AssertEqual is a wrapper around assert.Equal with context.
func AssertEqual(t *testing.T, expected, actual interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        return assert.Equal(t, expected, actual, msgAndArgs...)
}</span>

// AssertNotEmpty is a wrapper around assert.NotEmpty with context.
func AssertNotEmpty(t *testing.T, obj interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        return assert.NotEmpty(t, obj, msgAndArgs...)
}</span>

// AssertNil is a wrapper around assert.Nil with context.
func AssertNil(t *testing.T, obj interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        return assert.Nil(t, obj, msgAndArgs...)
}</span>

// AssertNotNil is a wrapper around assert.NotNil with context.
func AssertNotNil(t *testing.T, obj interface{}, msgAndArgs ...interface{}) bool <span class="cov0" title="0">{
        t.Helper()
        return assert.NotNil(t, obj, msgAndArgs...)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package testutil provides shared testing utilities and helpers.
package testutil

import (
        "context"
        "log/slog"
        "os"
        "time"

        "runvoy/internal/api"
        "runvoy/internal/constants"
)

// UserBuilder provides a fluent interface for building test users.
type UserBuilder struct {
        user *api.User
}

// NewUserBuilder creates a new UserBuilder with sensible defaults.
func NewUserBuilder() *UserBuilder <span class="cov0" title="0">{
        return &amp;UserBuilder{
                user: &amp;api.User{
                        Email:     "test@example.com",
                        CreatedAt: time.Now().UTC(),
                        Revoked:   false,
                },
        }
}</span>

// WithEmail sets the user's email.
func (b *UserBuilder) WithEmail(email string) *UserBuilder <span class="cov0" title="0">{
        b.user.Email = email
        return b
}</span>

// WithCreatedAt sets the user's creation time.
func (b *UserBuilder) WithCreatedAt(t time.Time) *UserBuilder <span class="cov0" title="0">{
        b.user.CreatedAt = t
        return b
}</span>

// WithLastUsed sets the user's last used time.
func (b *UserBuilder) WithLastUsed(t time.Time) *UserBuilder <span class="cov0" title="0">{
        b.user.LastUsed = t
        return b
}</span>

// Revoked marks the user as revoked.
func (b *UserBuilder) Revoked() *UserBuilder <span class="cov0" title="0">{
        b.user.Revoked = true
        return b
}</span>

// Build returns the constructed User.
func (b *UserBuilder) Build() *api.User <span class="cov0" title="0">{
        return b.user
}</span>

// ExecutionBuilder provides a fluent interface for building test executions.
type ExecutionBuilder struct {
        execution *api.Execution
}

// NewExecutionBuilder creates a new ExecutionBuilder with sensible defaults.
func NewExecutionBuilder() *ExecutionBuilder <span class="cov0" title="0">{
        return &amp;ExecutionBuilder{
                execution: &amp;api.Execution{
                        ExecutionID: "exec-test-123",
                        Command:     "echo 'test'",
                        Status:      "pending",
                        StartedAt:   time.Now().UTC(),
                        UserEmail:   "test@example.com",
                },
        }
}</span>

// WithExecutionID sets the execution ID.
func (b *ExecutionBuilder) WithExecutionID(id string) *ExecutionBuilder <span class="cov0" title="0">{
        b.execution.ExecutionID = id
        return b
}</span>

// WithCommand sets the execution command.
func (b *ExecutionBuilder) WithCommand(cmd string) *ExecutionBuilder <span class="cov0" title="0">{
        b.execution.Command = cmd
        return b
}</span>

// WithStatus sets the execution status.
func (b *ExecutionBuilder) WithStatus(status string) *ExecutionBuilder <span class="cov0" title="0">{
        b.execution.Status = status
        return b
}</span>

// WithUserEmail sets the user email.
func (b *ExecutionBuilder) WithUserEmail(email string) *ExecutionBuilder <span class="cov0" title="0">{
        b.execution.UserEmail = email
        return b
}</span>

// WithLogStreamName sets the log stream name.
func (b *ExecutionBuilder) WithLogStreamName(name string) *ExecutionBuilder <span class="cov0" title="0">{
        b.execution.LogStreamName = name
        return b
}</span>

// Completed marks the execution as completed.
func (b *ExecutionBuilder) Completed() *ExecutionBuilder <span class="cov0" title="0">{
        now := time.Now().UTC()
        b.execution.Status = "completed"
        b.execution.CompletedAt = &amp;now
        b.execution.ExitCode = 0
        return b
}</span>

// Failed marks the execution as failed.
func (b *ExecutionBuilder) Failed() *ExecutionBuilder <span class="cov0" title="0">{
        now := time.Now().UTC()
        b.execution.Status = "failed"
        b.execution.CompletedAt = &amp;now
        b.execution.ExitCode = 1
        return b
}</span>

// Build returns the constructed Execution.
func (b *ExecutionBuilder) Build() *api.Execution <span class="cov0" title="0">{
        return b.execution
}</span>

// TestContext creates a test context with a reasonable timeout.
// Note: The cancel function is intentionally not returned since test contexts
// are expected to be short-lived and will be cleaned up when the test completes.
func TestContext() context.Context <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.TestContextTimeout)
        _ = cancel // Silence unused warning - context will timeout automatically
        return ctx
}</span>

// TestLogger creates a logger suitable for testing (outputs to stderr).
func TestLogger() *slog.Logger <span class="cov0" title="0">{
        return slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
                Level: slog.LevelError, // Only show errors in tests
        }))
}</span>

// SilentLogger creates a logger that discards all output.
func SilentLogger() *slog.Logger <span class="cov0" title="0">{
        return slog.New(slog.NewTextHandler(os.NewFile(0, os.DevNull), &amp;slog.HandlerOptions{
                Level: slog.LevelError + 1, // Suppress all logs
        }))
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package main provides a utility to create a configuration file for runvoy.
package main

import (
        "context"
        "fmt"
        "log"
        "os"

        "runvoy/internal/config"
        "runvoy/internal/constants"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/cloudformation"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) != constants.ExpectedArgsCreateConfigFile </span><span class="cov0" title="0">{
                log.Fatalf("error: usage: %s &lt;stack-name&gt;", os.Args[0])
        }</span>

        <span class="cov0" title="0">stackName := os.Args[1]
        if stackName == "" </span><span class="cov0" title="0">{
                log.Fatalf("error: stack name is required")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), constants.ScriptContextTimeout)

        awsCfg, err := awsconfig.LoadDefaultConfig(ctx)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to load AWS configuration: %v", err)
        }</span>

        <span class="cov0" title="0">ctx2, cancel2 := context.WithTimeout(context.Background(), constants.ScriptContextTimeout)

        cfnClient := cloudformation.NewFromConfig(awsCfg)
        apiEndpoint, err := getAPIEndpointFromStack(ctx2, cfnClient, stackName)
        cancel2()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to resolve API endpoint from CloudFormation outputs: %v", err)
        }</span>

        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                // Config doesn't exist yet, create a new one
                cfg = &amp;config.Config{
                        APIEndpoint: apiEndpoint,
                        APIKey:      "", // API key will be set separately (e.g., via seed-admin-user)
                }
        }</span> else<span class="cov0" title="0"> {
                // Update existing config with new endpoint
                cfg.APIEndpoint = apiEndpoint
        }</span>

        <span class="cov0" title="0">if err = config.Save(cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to save config file: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("config file updated with API endpoint: %s", apiEndpoint)</span>
}

func getAPIEndpointFromStack(ctx context.Context, client *cloudformation.Client, stackName string) (string, error) <span class="cov0" title="0">{
        output, err := client.DescribeStacks(ctx, &amp;cloudformation.DescribeStacksInput{
                StackName: aws.String(stackName),
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to describe stack: %w", err)
        }</span>

        <span class="cov0" title="0">if len(output.Stacks) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("stack %s not found", stackName)
        }</span>

        <span class="cov0" title="0">stack := output.Stacks[0]
        for _, out := range stack.Outputs </span><span class="cov0" title="0">{
                if out.OutputKey != nil &amp;&amp; *out.OutputKey == "APIEndpoint" </span><span class="cov0" title="0">{
                        if out.OutputValue != nil </span><span class="cov0" title="0">{
                                return *out.OutputValue, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("APIEndpoint output not found in stack %s", stackName)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// TODO: this is a temporary script to seed the admin user into the database.
// Most probably overkill and needs some cleanup but not urgent for now, it does the job.
package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "time"

        "runvoy/internal/auth"
        "runvoy/internal/config"
        "runvoy/internal/constants"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/cloudformation"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

type userItem struct {
        APIKeyHash string    `dynamodbav:"api_key_hash"`
        UserEmail  string    `dynamodbav:"user_email"`
        CreatedAt  time.Time `dynamodbav:"created_at"`
        Revoked    bool      `dynamodbav:"revoked"`
}

func setupAPIKeyAndConfig() (cfg *config.Config, apiKey, apiKeyHash string) <span class="cov0" title="0">{
        var err error
        apiKey, err = auth.GenerateAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to generate API key: %v", err)
        }</span>

        <span class="cov0" title="0">cfg, err = config.Load()
        if err != nil </span><span class="cov0" title="0">{
                cfg = &amp;config.Config{
                        APIKey:      apiKey,
                        APIEndpoint: "",
                }
        }</span> else<span class="cov0" title="0"> {
                cfg.APIKey = apiKey
        }</span>

        <span class="cov0" title="0">apiKeyHash = auth.HashAPIKey(apiKey)
        return cfg, apiKey, apiKeyHash</span>
}

func seedAdminUser(ctx context.Context, dynamoClient *dynamodb.Client, tableName, adminEmail, apiKeyHash string) <span class="cov0" title="0">{
        existingUser, err := checkUserExists(ctx, dynamoClient, tableName, adminEmail)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to check if admin user exists: %v", err)
        }</span>
        <span class="cov0" title="0">if existingUser </span><span class="cov0" title="0">{
                log.Fatalf("error: admin user %s already exists in DynamoDB", adminEmail)
        }</span>

        <span class="cov0" title="0">item := userItem{
                APIKeyHash: apiKeyHash,
                UserEmail:  adminEmail,
                CreatedAt:  time.Now().UTC(),
                Revoked:    false,
        }

        av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to marshal DynamoDB item: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("seeding admin user %s into table %s...", adminEmail, tableName)

        _, err = dynamoClient.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName:           aws.String(tableName),
                Item:                av,
                ConditionExpression: aws.String("attribute_not_exists(api_key_hash)"),
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to seed admin user: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("admin user created in DynamoDB")</span>
}

func main() <span class="cov0" title="0">{
        if len(os.Args) != constants.ExpectedArgsSeedAdminUser </span><span class="cov0" title="0">{
                log.Fatalf("error: usage: %s &lt;admin-email&gt; &lt;stack-name&gt;", os.Args[0])
        }</span>

        <span class="cov0" title="0">adminEmail := os.Args[1]
        stackName := os.Args[2]
        if adminEmail == "" || stackName == "" </span><span class="cov0" title="0">{
                log.Fatalf("error: admin email and stack name are required")
        }</span>

        <span class="cov0" title="0">cfg, _, apiKeyHash := setupAPIKeyAndConfig()

        ctx, cancel := context.WithTimeout(context.Background(), constants.ScriptContextTimeout)
        awsCfg, err := awsconfig.LoadDefaultConfig(ctx)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to load AWS configuration: %v", err)
        }</span>

        <span class="cov0" title="0">ctx2, cancel2 := context.WithTimeout(context.Background(), constants.ScriptContextTimeout)
        cfnClient := cloudformation.NewFromConfig(awsCfg)
        tableName, err := getTableNameFromStack(ctx2, cfnClient, stackName)
        cancel2()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to resolve API keys table name from CloudFormation outputs: %v", err)
        }</span>

        <span class="cov0" title="0">dynamoClient := dynamodb.NewFromConfig(awsCfg)
        seedAdminUser(context.Background(), dynamoClient, tableName, adminEmail, apiKeyHash)

        if err = config.Save(cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf(
                        "error: failed to save config file: %v. "+
                                "Please save the key manually or store it somewhere safe: %s",
                        err, cfg.APIKey,
                )
        }</span>
        <span class="cov0" title="0">log.Println("config file saved")</span>
}

func checkUserExists(ctx context.Context, client *dynamodb.Client, tableName, email string) (bool, error) <span class="cov0" title="0">{
        result, err := client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(tableName),
                IndexName:              aws.String("user_email-index"),
                KeyConditionExpression: aws.String("user_email = :email"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":email": &amp;types.AttributeValueMemberS{Value: email},
                },
                Limit: aws.Int32(1),
        })
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to query user by email: %w", err)
        }</span>

        <span class="cov0" title="0">return len(result.Items) &gt; 0, nil</span>
}

func getTableNameFromStack(ctx context.Context, client *cloudformation.Client, stackName string) (string, error) <span class="cov0" title="0">{
        output, err := client.DescribeStacks(ctx, &amp;cloudformation.DescribeStacksInput{
                StackName: aws.String(stackName),
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to describe stack: %w", err)
        }</span>

        <span class="cov0" title="0">if len(output.Stacks) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("stack %s not found", stackName)
        }</span>

        <span class="cov0" title="0">stack := output.Stacks[0]
        for _, out := range stack.Outputs </span><span class="cov0" title="0">{
                if out.OutputKey != nil &amp;&amp; *out.OutputKey == "APIKeysTableName" </span><span class="cov0" title="0">{
                        if out.OutputValue != nil </span><span class="cov0" title="0">{
                                return *out.OutputValue, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("APIKeysTableName output not found in stack %s", stackName)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package main provides a utility to synchronize environment variables between Lambda functions and local .env files.
package main

import (
        "bufio"
        "context"
        "fmt"
        "log"
        "os"
        "regexp"
        "sort"
        "strings"

        "runvoy/internal/constants"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/lambda"
)

const (
        functionName = "runvoy-orchestrator"
        envFile      = ".env"
)

var (
        // envLineRegex matches a key-value pair in .env format: KEY=VALUE or KEY="VALUE"
        envLineRegex = regexp.MustCompile(`^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$`)
)

func main() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.ScriptContextTimeout)

        awsCfg, err := awsconfig.LoadDefaultConfig(ctx)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to load AWS configuration: %v", err)
        }</span>

        <span class="cov0" title="0">ctx2, cancel2 := context.WithTimeout(context.Background(), constants.ScriptContextTimeout)

        lambdaClient := lambda.NewFromConfig(awsCfg)

        functionConfig, err := lambdaClient.GetFunctionConfiguration(ctx2, &amp;lambda.GetFunctionConfigurationInput{
                FunctionName: aws.String(functionName),
        })
        cancel2()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to get Lambda function configuration: %v", err)
        }</span>

        <span class="cov0" title="0">lambdaVars := make(map[string]string)
        if functionConfig.Environment != nil &amp;&amp; functionConfig.Environment.Variables != nil </span><span class="cov0" title="0">{
                for k, v := range functionConfig.Environment.Variables </span><span class="cov0" title="0">{
                        lambdaVars[k] = v
                }</span>
        }

        <span class="cov0" title="0">if len(lambdaVars) == 0 </span><span class="cov0" title="0">{
                log.Fatalf("error: no environment variables found for Lambda function %s", functionName)
        }</span>

        <span class="cov0" title="0">totalCount := len(lambdaVars)
        envContent, updatedCount, newCount, err := mergeEnvFile(envFile, lambdaVars)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to merge .env file: %v", err)
        }</span>

        // Write merged content back to .env file
        <span class="cov0" title="0">if err = os.WriteFile(envFile, []byte(envContent), constants.ConfigFilePermissions); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: failed to write .env file: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf(
                "successfully synced %d environment variables from %s to .env (%d updated, %d new)",
                totalCount, functionName, updatedCount, newCount,
        )</span>
}

// readExistingEnvFile reads the existing .env file and returns lines.
func readExistingEnvFile(filePath string) ([]string, error) <span class="cov0" title="0">{
        var lines []string

        file, err := os.Open(filePath) //nolint:gosec // G304: File path from CLI arg is intentional
        if err == nil </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        _ = file.Close()
                }</span>()
                <span class="cov0" title="0">scanner := bufio.NewScanner(file)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        lines = append(lines, scanner.Text())
                }</span>
                <span class="cov0" title="0">if err = scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading .env file: %w", err)
                }</span>
        } else<span class="cov0" title="0"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error opening .env file: %w", err)
        }</span>

        <span class="cov0" title="0">return lines, nil</span>
}

// processExistingLines processes existing lines and updates with Lambda vars.
func processExistingLines(lines []string, lambdaVars map[string]string) (content strings.Builder, updated int) <span class="cov0" title="0">{
        var result strings.Builder
        updatedCount := 0

        for i, line := range lines </span><span class="cov0" title="0">{
                matches := envLineRegex.FindStringSubmatch(line)
                if len(matches) == constants.RegexMatchCountEnvVar </span><span class="cov0" title="0">{
                        key := matches[1]
                        if newValue, exists := lambdaVars[key]; exists </span><span class="cov0" title="0">{
                                formattedValue := formatEnvValue(newValue)
                                result.WriteString(fmt.Sprintf("%s=%s\n", key, formattedValue))
                                updatedCount++
                                delete(lambdaVars, key)
                        }</span> else<span class="cov0" title="0"> {
                                result.WriteString(line + "\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        result.WriteString(line + "\n")
                }</span>

                <span class="cov0" title="0">if i == len(lines)-1 &amp;&amp; len(lambdaVars) &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteString("\n")
                }</span>
        }

        <span class="cov0" title="0">return result, updatedCount</span>
}

// appendNewVars appends new variables from Lambda that weren't in the existing file.
func appendNewVars(result *strings.Builder, lambdaVars map[string]string, hasExistingLines bool) int <span class="cov0" title="0">{
        if len(lambdaVars) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">keys := make([]string, 0, len(lambdaVars))
        for k := range lambdaVars </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        if hasExistingLines </span><span class="cov0" title="0">{
                result.WriteString("# Synced from Lambda function\n")
        }</span>

        <span class="cov0" title="0">newCount := 0
        for _, key := range keys </span><span class="cov0" title="0">{
                formattedValue := formatEnvValue(lambdaVars[key])
                fmt.Fprintf(result, "%s=%s\n", key, formattedValue)
                newCount++
        }</span>

        <span class="cov0" title="0">return newCount</span>
}

// mergeEnvFile reads the existing .env file (if it exists) and merges it with Lambda values.
// It preserves comments, blank lines, and formatting while updating existing values and adding new ones.
// Returns: merged content, count of updated vars, count of new vars, error
func mergeEnvFile(filePath string, lambdaVars map[string]string) (content string, updated, added int, err error) <span class="cov0" title="0">{
        lines, err := readExistingEnvFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, err
        }</span>

        <span class="cov0" title="0">result, updatedCount := processExistingLines(lines, lambdaVars)
        newCount := appendNewVars(&amp;result, lambdaVars, len(lines) &gt; 0)

        return result.String(), updatedCount, newCount, nil</span>
}

// formatEnvValue formats a value for .env file output, adding quotes if necessary.
// Handles values that contain spaces, quotes, or special characters.
func formatEnvValue(value string) string <span class="cov0" title="0">{
        // If value contains quotes, spaces, or starts with #, wrap in quotes
        if strings.Contains(value, "\"") || strings.Contains(value, " ") ||
                strings.Contains(value, "#") || strings.Contains(value, "\n") ||
                strings.Contains(value, "\t") || strings.HasPrefix(value, "'") </span><span class="cov0" title="0">{
                // Escape quotes in the value
                escaped := strings.ReplaceAll(value, "\"", "\\\"")
                escaped = strings.ReplaceAll(escaped, "\n", "\\n")
                escaped = strings.ReplaceAll(escaped, "\t", "\\t")
                return fmt.Sprintf("%q", escaped)
        }</span>
        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package main provides a utility to update the README.md with the latest CLI help output.
package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/exec"
        "regexp"
        "strings"

        "runvoy/internal/constants"
)

const startMarker = "&lt;!-- CLI_HELP_START --&gt;"
const endMarker = "&lt;!-- CLI_HELP_END --&gt;"
const readmePath = "README.md"

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; constants.MinimumArgsUpdateReadmeHelp </span><span class="cov0" title="0">{
                log.Fatalf("usage: %s &lt;cli-binary-path&gt;", os.Args[0])
        }</span>

        <span class="cov0" title="0">cliBinary := os.Args[1]
        if cliBinary == "" </span><span class="cov0" title="0">{
                log.Fatalf("error: cli binary path is required")
        }</span>

        <span class="cov0" title="0">helpOutput, err := captureHelpOutput(cliBinary)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error capturing help output: %s", err)
        }</span>

        <span class="cov0" title="0">helpSection := generateHelpSection(helpOutput)

        if err = updateREADME(readmePath, helpSection); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error updating %s: %s", readmePath, err)
        }</span>

        <span class="cov0" title="0">log.Printf("updated %s with latest CLI help output", readmePath)</span>
}

func captureHelpOutput(cliBinary string) (string, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), constants.LongScriptContextTimeout)
        defer cancel()

        cmd := exec.CommandContext(ctx, cliBinary, "--help")
        output, err := cmd.CombinedOutput()
        return strings.TrimSpace(string(output)), err
}</span>

func generateHelpSection(helpOutput string) string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString("### Available Commands\n\n")
        b.WriteString("To see all available commands and their descriptions:\n\n")
        b.WriteString("```bash\n")
        b.WriteString("runvoy --help\n")
        b.WriteString("```\n\n")
        b.WriteString("```bash\n")
        b.WriteString(helpOutput)
        b.WriteString("\n```\n\n")
        b.WriteString("For more details about a specific command, use:\n\n")
        b.WriteString("```bash\n")
        b.WriteString("runvoy [command] --help\n")
        b.WriteString("```\n\n")
        b.WriteString("For example, to see all user management commands:\n\n")
        b.WriteString("```bash\n")
        b.WriteString("runvoy users --help\n")
        b.WriteString("```\n")
        return b.String()
}</span>

func updateREADME(readmePath, helpSection string) error <span class="cov0" title="0">{
        content, err := os.ReadFile(readmePath) //nolint:gosec // G304: README.md path is a constant
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read %s: %w", readmePath, err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        if !strings.Contains(contentStr, startMarker) || !strings.Contains(contentStr, endMarker) </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find %s and %s markers in %s",
                        startMarker, endMarker, readmePath,
                )
        }</span>

        // Replace content between markers using regex
        // Use (?s) flag to make . match newlines
        <span class="cov0" title="0">pattern := regexp.MustCompile(
                `(?s)` + regexp.QuoteMeta(startMarker) + `.*?` + regexp.QuoteMeta(endMarker),
        )
        replacement := startMarker + "\n" + helpSection + "\n" + endMarker
        newContent := pattern.ReplaceAllString(contentStr, replacement)

        if err = os.WriteFile(readmePath, []byte(newContent), constants.ConfigFilePermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write %s: %w", readmePath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
